/*
 Navicat MySQL Data Transfer

 Source Server         : 本地
 Source Server Type    : MySQL
 Source Server Version : 80020
 Source Host           : localhost:3306
 Source Schema         : my_blog_db

 Target Server Type    : MySQL
 Target Server Version : 80020
 File Encoding         : 65001

 Date: 27/06/2020 20:33:17
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_admin_user
-- ----------------------------
DROP TABLE IF EXISTS `tb_admin_user`;
CREATE TABLE `tb_admin_user`  (
  `admin_user_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '管理员id',
  `login_user_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '管理员登陆名称',
  `login_password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '管理员登陆密码',
  `nick_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '管理员显示昵称',
  `locked` tinyint(0) NULL DEFAULT 0 COMMENT '是否锁定 0未锁定 1已锁定无法登陆',
  PRIMARY KEY (`admin_user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_admin_user
-- ----------------------------
INSERT INTO `tb_admin_user` VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 'chy_18883701161', 0);

-- ----------------------------
-- Table structure for tb_blog
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog`;
CREATE TABLE `tb_blog`  (
  `blog_id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '博客表主键id',
  `blog_title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客标题',
  `blog_sub_url` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客自定义路径url',
  `blog_cover_image` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客封面图',
  `blog_content` mediumtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客内容',
  `blog_category_id` int(0) NOT NULL COMMENT '博客分类id',
  `blog_category_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客分类(冗余字段)',
  `blog_tags` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客标签',
  `blog_status` tinyint(0) NOT NULL DEFAULT 0 COMMENT '0-草稿 1-发布',
  `blog_views` bigint(0) NOT NULL DEFAULT 0 COMMENT '阅读量',
  `enable_comment` tinyint(0) NOT NULL DEFAULT 0 COMMENT '0-允许评论 1-不允许评论',
  `is_deleted` tinyint(0) NOT NULL DEFAULT 0 COMMENT '是否删除 0=否 1=是',
  `create_time` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '添加时间',
  `update_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '修改时间',
  PRIMARY KEY (`blog_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_blog
-- ----------------------------
INSERT INTO `tb_blog` VALUES (6, 'Git', '', 'http://127.0.0.1:9501/admin/dist/img/rand/23.jpg', '@[TOC](目录)\n&nbsp;\n\n### Git简介\nGit 是一个开源的分布式版本控制系统，与SVN不同，Git采用分布式版本库，不需要服务器端软件的支持。\n\n&nbsp;\n\nGit 与 SVN的区别\n - Git 是分布式的，SVN 不是，这是 Git 、SVN最核心的区别\n - Git 使用元数据存储版本信息，而 SVN 使用文件来存储版本信息\n - Git 、SVN 分支的概念不同\n - Git 没有一个全局的版本号， SVN 有\n - Git 的内容完整性要优于 SVN。Git 的内容存储使用SHA-1 哈希算法，能确保内容的完整性，在遇到磁盘故障、网络问题时降低对版本库的影响\n\n &nbsp;\n \nGit的分布式特点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512084313916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n\n&nbsp;\n\n### Git的安装\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512084613105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n不需要创建桌面图标，也不需要GUI界面\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512085046532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n只用bash就够了\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512085129343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n建立https连接时，使用哪种安全连接库\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512085321879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n命令行风格\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512085413645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n使用哪种终端（命令行）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512085619466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n\n安装完成后，对桌面单击右键，有git bash说明安装成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512085743199.png)\n&nbsp;\n\n### Git的配置\n1. 配置用户名、邮箱\n提交时会附带个人信息，这样别人才知道是谁提交的。打开git终端，执行\n```bash\n	git config --global user.name \"chy\"\n	git config --global user.email \"xxxxxxxx@qq.com\"\n	git config --list  #列出配置信息，查看配置是否成功，如果有我们配置的用户名、邮箱，说明配置成功\n```\n\n&nbsp;\n\n2. 配置ssh\n提交到远程仓库或者clone私人仓库时，每次都要验证密码，ssh是使用秘钥进行验证，公钥放到远程仓库，私钥放在自己的电脑上，提交到远程仓库时自动验证公钥、私钥，无需我们输入密码。\n\n```bash\ncd ~/.ssh  #先查看是否配置了ssh，如果提示No such file or directory说明没有配置\n\nssh-keygen -t rsa  #生成秘钥\n#ssh-keygen -t rsa -C \"xxxxxxx@qq.com\"  #可以用-C指定参与生成秘钥的字符串，对该字符串进行加工来生成秘钥\n```\n\n会有3个提示项，让你输入私钥、公钥的存储位置，密钥生成规则（即上面的-C），直接回车，使用默认的即可。\n\n在C:\\Users\\你的用户名\\.ssh\\会生成2个文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512092313912.PNG)\n用记事本打开公钥文件，把里面的公钥复制粘贴到远程仓库（比如说你的github）上\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200512092441126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n```bash\nssh -T git@github.com  #验证是否配置成功、是否能登录远程仓库\n```\n如果看到以下内容，说明ssh配置成功\n\n> Hi xxx! You\'ve successfully authenticated, but GitHub does not provide shell access.\n\n&nbsp;\n\n### 配置过程中可能遇到的问题\n - Git终端粘贴的快捷键是Shift+Insert，不是Ctrl+V\n\n - 如果报错 \n> bash: $\'\\302\\226git\': command not found\n\n2种可能：命令敲错了，或者粘贴命令时开头有多余的空格。\n如果是第二种，去除多余的空格或者删除开头的空格重新敲空格即可。\n\n\n', 0, '默认分类', 'git', 1, 2, 0, 1, '2020-06-27 19:05:58', '2020-06-27 19:05:58');
INSERT INTO `tb_blog` VALUES (7, '线程、线程池的使用', '', 'http://127.0.0.1:9501/admin/dist/img/rand/37.jpg', '\n\n### 进程\n进程是是应用程序运行的载体，是程序的一次执行过程，是临时的、有生命周期的，由程序、数据和进程控制块三部分组成，进程之间相互独立。\n&nbsp; \n\n**进程的三种基本状态**\n- 就绪(ready)状态：进程准备就绪，获得CPU时间片后可立即运行。就绪的进行放在就绪队列中，操作系统按指定的调度策略分配cpu时间片。\n- 运行(running)状态：进程获取到cpu的时间片，开始执行代码。时间片用完后，回到就绪状态。\n- 阻塞（blocked ）状态：进程暂停执行，等待某一事件的发生，比如等待IO完成、用户输入等。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605111811318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n这三种只是进程的基本状态，进程并不止这三种状态。\n\n&nbsp;\n\n### 线程\n线程是程序执行的最小单元，一个进程可以有一个或多个线程（至少有一个），同一进程中的多个线程共享所在进程的内存空间。\n&nbsp;\n\n#### 进程、线程的区别\n-  进程是操作系统分配资源的基本单位，线程是程序执行的最小单位\n- 进程之间相互独立，同一进程下的线程共享进程的内存空间\n- 线程上下文切换比进程上下文切换快得多\n\n&nbsp;\n\n#### 线程的6种状态\n**1、New  新建**\n已创建线程，但尚未调用start()启动线程\n\n &nbsp;\n \n**2、RUNNABLE  可运行**\nJava把就绪（ready）、运行（running）两种状态合并为一种状态：可运行（runnable）。调用了start()启动线程后，线程就处于可运行状态（就绪）；线程获取到时间片开始执行代码，就处于运行（running）状态。\n\n操作系统只给就绪队列中（就绪状态）的线程分配时间片。\n\n&nbsp; \n\n**3、BLOCKED  阻塞**\n正在执行的线程需要等待特定事件的发生、完成，就会进入阻塞状态，常见的有：①等待获取锁，②等待IO完成。线程进入阻塞状态后会让出cpu使用权，等待的事件发生、完成后线程进入就绪状态，进入调度队列，等待操作系统分配时间片。\n\n&nbsp;\n\n**4、WAITING  （无限期）等待**\n正在执行的线程中调用某些方法会让线程进入无限期等待状态，进入无限期等待状态的线程会让出cpu使用权，被其它线程显式唤醒后，进入就绪状态。\n\n进入无限期等待 | 唤醒\n:-- | :--\nObject.wait() | Object.notify() 或 Object.notifyAll()\nThread.join() | 被调用的线程执行完毕\nLockSupport.park() | LockSupport.unpark(currentThread)\n \n&nbsp; \n\n**5、TIMED_WAITING  限时等待**\n在正在执行的线程中调用某些方法会让线程进入限时等待状态，进入限时等待状态的线程会让出cpu使用权，在指定时间后会自动被唤醒，也可以中途被唤醒，唤醒后进入就绪状态。\n\n进入限时等待 | 唤醒\n:-- | :--\nThread.sleep(time) | sleep时间结束\nObject.wait(time) | wait时间结束，或者调用Object.notify() / notifyAll()   \nLockSupport.parkNanos(time)/parkUntil(time) | park时间结束，或者调用LockSupport.unpark(currentThread)\n\n&nbsp; \n\n**6、TERMINATED  消亡**\n线程执行完毕，或者线程执行时发生异常、错误无法继续执行，会进入消亡状态。\n\n&nbsp;\n\n####  线程的生命周期\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605123143468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n\n&nbsp;\n\n#### 线程的2种创建方式\n**1、继承Thread类，重写run()方法**\n```java\npublic class Thread1 extends Thread{\n\n    @Override\n    public void run() {\n        //.....  //要执行的代码\n    }\n\n}\n```\n\n```java\n Thread1 thread1 = new Thread1();\n thread1.start();\n```\n&nbsp;\n\n**2、实现Runnable接口**\n```java\npublic class MyRunnable implements Runnable{\n\n    @Override\n    public void run() {\n        //.....   //要执行的代码\n    }\n\n}\n```\n\n```java\nMyRunnable myRunnable = new MyRunnable();\nThread thread = new Thread(myRunnable);  //要使用Thread来包装\nthread.start();\n```\nRunnable是函数式接口，可使用lambda表达式\n\n```java\nThread thread = new Thread(() -> {\n    //......\n});\n```\n&nbsp;\n\n实际开发中一般使用第二种\n- java只支持单继承，第一种继承Thread后不能再继承其它类；使用第二种在实现接口的基础上可以继承类\n- 第二种代码可以共享\n&nbsp;\n\n**start()、run()的区别**\n- start()会在jvm中创建一条新线程，分配线程所需的资源，并调用run()方法执行run()方法中的代码，实现了多线程\n- run()只是一个普通方法，直接调用run()方法只是在当前线程中执行run()方法中的代码，并不会创建新线程，不能实现多线程\n\n&nbsp;\n\n#### 线程常用方法\n**1、线程的基本信息**\n```java\nThread thread = Thread.currentThread();  //获取当前线程\nThread thread = new Thread1();\n\n\nthread.getId(); //线程id\nthread.getName(); //线程名\nthread.getPriority(); //线程优先级\nthread.getState(); //线程状态\nthread.isDaemon();  //是否是守护线程\n\n\nthread.setName(\"my_thread\"); //设置线程名，默认主线程是main、其它线程以Thread-n的形式命名\n\nthread.setPriority(5); //设置线程优先级，可使用[1,10]上的整数，也可以使用常量，默认5，优先级高的线程优先分配时间片\nthread.setPriority(Thread.MIN_PRIORITY); //1\nthread.setPriority(Thread.NORM_PRIORITY); //5\nthread.setPriority(Thread.MAX_PRIORITY); //10\n\nthread.setDaemon(false); //是否作为守护线程，默认false\n\nthread.start(); //线程的基本信息要在start()启动线程之前设置\n```\n不同的操作系统，对线程优先级的支持有差异，不要过度依赖于线程优先级，尽量不要设置为[1,10]上的其它数字，使用预定义的常量（1、5、10）即可。\n&nbsp;\n\n线程分为2类：用户线程、守护线程，默认为用户线程，main线程默认也是用户线程。守护线程是用户线程的守护者，常见的守护线程比如gc线程。只要还有用户线程在执行，程序就不会终止；如果程序中没有用户线程在执行、只有守护线程在执行，则jvm直接退出，程序终止运行。\n\n守护线程不可控，尽量少用守护线程，不要在守护线程中进行读写操作、逻辑计算。\n\n&nbsp;\n \n**2、join()**\nThread的实例方法，在一个线程中加入另一条已启动的线程，可用于线程间通信\n```java\nThread1 thread1 = new Thread1();\nthread1.start();\n\nthread1.join();  //在当前线程中加入thread1\n```\n先执行加入的线程thread1，等加入的线程执行完毕，才会继续执行当前线程\n\n&nbsp;\n\n**3、yield()、sleep()**\n```java\nThread.yield();  //线程让步，当前线程让出cpu的使用权，进入就绪状态\n\nThread.sleep(500); //线程休眠，当前线程休眠指定ms，会让出cpu的使用权，但不会释放锁，指定时间后自动苏醒，进入就绪状态\n```\n都是Thread类的静态方法，操作的都是当前线程，都会让出cpu的使用权。\n\nyield()是不可靠的，只是提示线程调度器当前线程愿意让出cpu使用权，由线程调度器决定是否让出cpu使用权，不是一定会让出。\n\n&nbsp;\n\n**4、wait()、notify()、notifyAll()**\n均是Object类的实例方法，常用于线程间通信。\n\n这三个方法使用的前提是已经获取到了互斥锁，所以这三个方法都只能在同步代码块中使用，且操作的要是同一把锁（锁对象的内存地址相同）\n\n```java\npublic class Thread1 extends Thread {\n    public static Object lock = new Object(); //锁。可以把要使用的公共资源直接作为锁，也可以把一个Object对象作为锁，获取到锁后，才可以操作公共资源。要是同一把锁（地址相同）\n\n    @Override\n    public void run() {\n        //....\n        \n        //同步代码块\n        synchronized (lock){  //获取锁，获取到锁后自动执行里面的代码\n            //.....  //操作资源\n\n            lock.notify();  //如果同步代码块中：释放锁后还有代码要执行，则应该使用notify()、notifyAll()进行等待\n            // lock.notifyAll();\n\n            try {\n                lock.wait(); //让出cpu使用权，释放锁，进入无限期等待，如果要继续运行，需要在其它线程中显式唤醒\n　　　　　　　　　//lock.wait(10000);  //限时等待，指定时间后自动唤醒进入ready状态\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            \n            //.....  //如果同步代码块中、wait()之后还有代码，唤醒后进入ready状态，获取到时间片后、需要重新获取锁才能继续执行后面的代码\n        }\n        \n        //.....  //如果同步代码块后还有代码，唤醒后进入ready状态，获取时间片后就可以继续执行，无需获取锁\n        \n    }\n\n}\n```\nwait()释放锁后，锁分配给等待这个锁的哪个线程？\n\n等待池WaitSet中存放等待锁的线程，锁池EntryList是针对对象锁而言的，把对象作为锁，锁被释放后进入锁池中。\n&nbsp;\n\n**notify()、notifyAll()的区别**\n- notify()是在等待池中等待该锁的所有线程中，随机选择一个线程来获取锁\n- notifyAll()是让等待池中等待该锁的所有线程，都来竞争锁\n\n&nbsp;\n\n**5、park()、parkUntil()、parkNanos()、unpark()**\n均为LockSupport类的静态方法\n\n```java\n//将当前线程挂起，让出cpu使用权，进入无限期等待状态\nLockSupport.park();\n\n//参数是long型的时间戳，将当前线程挂起，让出cpu使用权，进入限时等待状态，到达指定时间自动唤醒，进入就绪状态\nLockSupport.parkUntil(100000000000L);  //ms\nLockSupport.parkNanos(100000000000L);   //ns（纳秒）\n\n//unpark()可以解处指定线程park()、parkUntil()、parkNanos()的挂起，将线程恢复到运行（就绪）状态。参数是Thread实例,指定要解除挂起的线程\nLockSupport.unpark(thread1); \n```\npark()、parkUntil()、parkNanos()都会让出cpu使用权，但不释放锁。\n&nbsp;\n\n与wait()、notify()相比，LockSupport更加灵活\n- LockSupport的方法不要求写在同步代码块中，线程间不需要使用同步锁，实现了线程间的解耦\n- unpark()方法可以先于park()方法调用，不用担心执行的先后顺序\n\n&nbsp;\n\n**6、interrupt()  线程中断**\n\nThread类的实例方法\n- 如果对处于等待、限时等待的线程使用，会中断等待、限时等待状态，进入就绪状态。sleep()、wait()等方法都是放在try中的，如果在等待期间，在其它线程中使用interrupt()中断，会抛出中断异常，并立即被唤醒，进入ready状态。\n- 如果对正在运行的线程使用，会给该线程设置一个中断标志，由该线程自己决定在哪个适合的代码位置暂停，往往不会立刻停止，需要判断是否已暂停\n\n① isInterrupted()  &emsp;Thread类的实例方法，判断指定线程是否已中断\n② interrupted()   &emsp;Thread类的静态方法，判断当前线程是否已中断，并清除之前设置的中断标志\n\n&nbsp;\n\n**7、使线程进入等待状态、限时等待状态的方法对比**\n方法 | 类型 | 锁  | 使用要求 | 用途\n:-- | :-- | :--| :-- | :--\nsleep() | Thread类的静态方法 | 不释放锁 | 无限制 | 线程内控制\nwait() | Object的实例方法 | 释放锁 | 只能在同步代码块中使用、要使用同一把锁 | 线程间通信\npark()系列 | 均为LockSupport类的静态方法 | 不释放锁 | 无限制 | 线程内控制，unpark()可用于线程间通信\n\n均可用interrupt()唤醒\n\n&nbsp;\n\n#### 线程协作\n常见的线程协作模式是生产者/消费者。 \n\n一个线程作为生产者，生产要处理数据，将数据放到仓库中；可使用juc的LinkedBlockingQueue作为仓库，队列，自然是先进先出的；一个线程作为消费者，消费|处理仓库中的数据。LinkedBlockingQueue是阻塞队列，取不到元素（队列为空）时会一直阻塞直到有元素可取。\n\n&nbsp;\n\n#### 线程死锁\n多条线程彼此都在等待对方持有的锁，永远无法继续往下执行。\n\n&nbsp;\n\n### 线程池\n**为什么要使用线程池？**\nnew出一个线程，只是创建了一个对象，并没有分配线程所需的资源，调用start()才会分配线程所需的资源，并启动线程。 \n\n线程池预先分配线程所需的资源，把线程放进去，直接使用已分配好的资源；线程执行完毕，线程池回收这条线程的线程资源，留给新放入的线程使用。使用线程池，减少了分配、销毁线程资源的时间开销。\n&nbsp;\n\njuc提供了线程池\n```java\n//创建线程池。前2个参数是核心线程数、最大线程数，中间2个参数指定空闲线程的存活时间，最后一个参数指定队列\n//线程池放不下的会自动放到阻塞队列中，可指定队列大小\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 50, 5, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>(100));\n\n\n//把线程放到线程池中，会自动开始执行线程。参数是Runnable接口的实例，Thread已实现Runnable接口\n//execute、submit作用相同，只是返回值类型不同\nthreadPoolExecutor.execute(()->{ });  //返回void，如果队列也放不下会抛出异常\nthreadPoolExecutor.submit(()->{ });  //返回Future\n```\n&nbsp;\n\njuc也提供了Executor框架，可以很简便地创建线程池\n```java\n//创建并返回一个线程池Executors可以\nExecutorService es = Executors.newSingleThreadExecutor();  //线程池容量为1，不能扩容\nExecutorService es = Executors.newFixedThreadPool(10);  //指定线程池容量，不能扩容\nExecutorService es = Executors.newScheduledThreadPool(10);  //指定核心线程数，线程池容量不够时自动扩容。可定时执行\nExecutorService es = Executors.newCachedThreadPool();  //线程池容量不够时自动扩容。会自动回收空闲线程\n```\nExecutors创建的线程池不能手动设置队列容量，队列容量默认是Integer.MAX_VALUE，如果没做限流，队列中大量的线程严重影响性能，甚至可能会撑爆内存\n\n核心线程数不宜设置太多，太多会导致切换上下文的时间开销较大，一般设置为cpu核心数即可。\n\n&nbsp;\n\n**加入线程池执行的判断**\n- 如果运行的线程数小于核心线程数，即使线程池中有空闲线程，也会创建新线程来处理\n- 如果运行的线程数大于核心线程数、小于线程池最大线程数，则使用空闲线程来处理，如果没有空闲线程，则创建新线程来处理\n- 如果运行的线程数大于线程池最大线程数，但队列还未满，放到队列中等待\n- 如果队列已满，用指定的拒绝策略处理\n\n&nbsp;\n\n**线程池的拒绝（饱和）策略**\n线程池放不下会放到队列中，如果队列满了，如何处理要加入的线程？\n\n有4种策略\n- AbortPolicy：抛出异常（默认策略）\n- CallerRunsPolicy：用调用者所在线程来执行\n- DiscardPolicy：丢弃要加入的线程\n- DiscardOldestPolicy：丢弃队列中的第一个线程\n\n可以自定义策略\n\n&nbsp;\n\n**线程池的5种状态**\n- RUNNING：可以接收新线程，可以处理队列中的线程\n- SHUTDOWN：不接收新线程，但可以处理队列中的线程\n- STOP：不接收新线程，也不处理队列中的线程\n- TIDYING：终止所有任务\n- TERMINATED：terminated()方法执行完后进行此状态\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608100617828.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n&nbsp;\n\n### 并发编程\n并发：同时存在、交替执行\n并行：同时存在，同时执行。同时执行依赖多核cpu。\n&nbsp;\n一个进程中可以有多条线程，如果是单核cpu，只能交替执行；如果是多核cpu，每个核可以执行1条线程，提高执行效率。\n&nbsp;\n多线程在多核cpu下才有优势，在单核cpu下有线程上下文切换的时间开销，执行效率反而不如单线程。\n\n&nbsp;\n\n**什么时候适合使用多线程？**\n\n- 任务会阻塞线程，导致后续的代码不能尽快执行，eg. 文件IO、大量运算\n- 任务执行时间过长，可以划分为互补干扰的子任务，eg. 多线程分段下载 \n- 间断性任务，eg. 定时统计\n- 任务本身需要协作执行，eg. 生产者/消费者模式的线程协作\n\n&nbsp;\n\n**多线程要考虑的问题**\n- 硬件资源：cpu核心数、内存、带宽等\n- 软件资源：数据库最大连接数、操作系统允许打开的socket最大数量等\n- 线程安全\n- 线程协作、线程通信\n\n\n&nbsp;\n\n**频繁切换上下文，会带来一定的性能开销，如何减少上下文切换的开销？**\n- 线程数不宜太多，避免创建不需要的线程\n- 无锁并发编程。未获取到锁会引起线程切换，可以用一些办法避免使用锁，减少线程间上下文的切换，eg. 将数组、有序集合按照hashCode取模进行分段，不同的线程处理不同段的数据；使用CAS算法\n\n&nbsp;\n\n### 为什么不使用多进程而是使用多线程？\n- 线程更加轻量级，启动、消亡所需时间短，需要的系统资源比进程少得多，且可以共享进程的内存空间\n- 多进程的运行不可预期，且测试困难\n\n', 26, '多线程', '多线程', 1, 1, 0, 0, '2020-06-27 19:21:48', '2020-06-27 19:21:48');
INSERT INTO `tb_blog` VALUES (8, '并发、线程安全', '', 'http://127.0.0.1:9501/admin/dist/img/rand/36.jpg', '\n### 概念、理论\n并发：多个线程操作相同的资源，优点：效率高、资源利用率高，缺点：线程可能不安全、数据可能不一致，需要使用一些方式保证线程安全、数据一致\n\n高并发：服务器能同时处理大量请求\n\n线程安全：当多个线程访问某个类，不管采用何种调度方式、线程如何交替执行，这个类都能表现出正确的行为。\n\n&nbsp;\n\n#### 造成线程不安全的原因\n- 存在共享资源\n- 多个线程同时操作同一共享资源，操做不具有原子性\n\n&nbsp;\n\n#### 如何实现线程安全？\n- 使多线程不同时操作同一共享资源：eg. 只使用单线程、必要的部分加锁、使用juc的并发容器、并发工具类\n- 使对共享资源的操作具有原子性：eg.使用原子类\n- 不共享资源：eg. 使用ThreadLocal\n- 用final修饰共享资源，使之只读、不可修改\n\n只要实现以上任意一点，即可实现线程安全\n\n&nbsp;\n\n#### 互斥锁的特性\n- 互斥性：同一时刻只能有1个线程对这部分数据进行操作，互斥性也常叫做操作的原子性\n- 可见性：如果多个线程同时操作相同的数据（读、写），对数据做的修改能及时被其它线程观测到。可见性用happens-before原则保证\n\n&nbsp;\n\n#### 锁的实现原理\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608002234299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n获取锁：把主内存中对应的共享资源读取到本地内存中，将主内存中的该部分共享资源置为无效\n释放锁：把本地内存中的资源刷到主内存中，作为共享资源，把本地内存中的该部分资源置为无效\n\n&nbsp;\n\n#### juc包简介\njuc包提供了大量的支持并发的类，包括\n- 线程池executor\n- 锁locks，locks包及juc下一些常用类CountDownLatch、Semaphore基于AQS实现。jdk将同步的通用操作封装在抽象类AbstractQueuedSynchronizer中，acquire()获取资源的独占权（获取锁），release()释放资源的独占权（释放锁）\n- 原子类atomic，atomic包基于CAS实现，实现了多线程下无锁操作\n- 并发容器（集合）collections\n- 并发工具类tools\n\n&nbsp;\n\n### 实现线程安全的常用方式\n#### synchronized\n##### synchronized的用法\n```java\n// 修饰普通方法\npublic synchronized void a(){\n\n}\n\n// 修饰静态方法\npublic static synchronized void b(){\n\n}\n\n\npublic static Object lock = new Object();\n\npublic void c(){\n    // 修饰代码块。同步代码块，锁住一个对象\n    synchronized (lock){\n        \n    }\n\n}\n```\nsynchronized可以修饰方法、代码块，修饰的操作是原子性的，同一时刻只能有1个线程访问、执行\n- 修饰普通方法，执行该方法时会自动锁住该方法所在的对象\n- 修饰静态方法，加的是类锁，执行该方法时会锁住所在类的class对象，即锁住该类所有实例\n- 修饰代码块，加的是对象锁，会锁住指定对象\n\n如果要修饰方法，尽量用普通方法，因为静态方法因为会锁住类所有的实例，严重影响效率。\n\n&nbsp;\n\n##### synchronized的实现原理\nsynchronized使用对象作为锁，对象在内存的布局分为3部分：对象头、实例数据、对齐填充，对象头占64位\n- 前32位是Mark Word，存储对象的hashCode、gc分代年龄、锁类型、锁标志位等信息\n- 后32位是类型指针，存储对象所属的类的元数据的引用，jvm通过类型指针确定此对象是哪个类的实例\n&nbsp;\n\nMark Work结构如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608003612857.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n每个对象都关联了一个Monitor（这也是为什么每个对象都可以作为锁的原因），锁的指针指向对象对应的Monitor，当某个线程持有锁时，Monitor处于锁定状态\n\n&nbsp;\n\n##### synchronized的4种锁状态及膨胀方向\n无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁\n- 无锁：没有线程要获取锁，未加锁\n- 偏向锁：大多数情况下，锁不存在多线程竞争，很多时候都是同一线程多次申请锁。偏向锁简化了线程再次申请锁的流程，减少了同一线程多次获取同一个锁的代价。偏向锁只适用于锁竞争不激烈的情况\n- 轻量级锁：适用于锁竞争一般的情况\n- 重量级锁：适用于锁竞争激烈的情况\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608002615468.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n\n\n&nbsp;\n\n#### 使用Lock接口\nsynchronized使用前自动加锁、使用完自动释放锁，很方便。synchronized是悲观锁的实现，每次操作共享资源前都要先加锁；以前是重量级锁，性能低，经过不断优化，量级轻了很多，性能和Lock相比差距不再很大。\n\nLock需要自己加锁、用完需要自己释放。Lock是乐观锁的实现，每次先操作共享资源，提交修改时再验证共享资源是否被其它线程修改过；Lock是轻量级锁，性能很高。\n\nLock接口有很多实现类，常用的有ReentrantLock 可重入锁、ReadWriteLock 读写锁，也可以自己实现Lock接口来实现自定义的锁。\n\n&nbsp;\n\n##### ReentrantLock 可重入锁\n重入：一个线程再次获取自己已持有的锁\n```java\npublic class Xxx{\n    public final static ReentrantLock lock=new ReentrantLock(); //锁对象都可以加个final防止被修改\n    //public final static ReentrantLock lock=new ReentrantLock(true);  //可指定是否是公平锁，缺省时默认false\n\n    public void a() {\n        lock.lock();  //获取锁，如果未获取到锁，会一直阻塞在这里\n        // lock.tryLock();  //只尝试1次，如果未获取到锁，直接失败不执行后面的代码\n        \n        //....   //操作共享资源\n        \n        lock.unlock();  //释放锁\n    }\n    \n    public void b() {\n        try {\n            lock.tryLock(30, TimeUnit.SECONDS);  //如果获取锁失败，会在指定时间内不停尝试。此句代码可能会抛出异常\n            //.... //操作共享资源\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }finally {\n            if (!lock.isFair()){\n                lock.unlock();  //如果获取到锁，最终要释放锁\n            }\n        }\n    }\n\n    public void c() {\n        lock.lock();\n        try {\n            //.... //操作共享资源\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            lock.unlock();  //如果操作共享资源时可能发生异常，最终要释放锁\n        }\n    }\n    \n}\n```\n\n&nbsp;\n\n##### ReentrantLock如何实现公平锁、非公平锁？\n使用链表存储等待同一把锁的线程，将线程添加到链表尾部，释放锁后\n- 公平锁：将锁分配给链表头部的线程\n- 非公平锁：将锁分配个链表中的任意一个线程\n\n将获得锁的线程从链表中移出\n\n&nbsp;\n\n##### synchronized、ReentrantLock的比较\n- synchronized是关键字，ReentrantLock是类\n- 机制不同，synchronized是操作对象的Mark Word，ReentrantLock是使用Unsafe类的park()方法加锁\n- synchronized是非公平锁，ReentrantLock可以设置是否是公平锁\n- ReentrantLock可以实现比synchronized更细粒度的控制，比如设置锁的公平性\n- 锁竞争不激烈时，synchronized的性能往往要比ReentrantLock高；锁竞争激烈时，synchronized膨胀为重量级锁，性能不如ReentrantLock\n- ReentrantLock可以设置获取锁的等待时间，避免死锁\n\n&nbsp;\n\n##### ReadWriteLock 读写锁\nReadWriteLock将锁细粒度化分为读锁、写锁，synchronized、ReentrantLock 同一时刻最多只能有1个线程获取到锁，读锁同一时刻可以有多个线程获取锁，但都只能进行读操作，写锁同一时刻最多只能有1个线程获取锁进行写操作，其它线程不能进行读写操作。\n\n读写锁做了更加细致的权限划分，加读锁时多个线程可以同时对共享资源进行读操作，相比于synchronized、ReentrantLock，在以读为主的情况下可以提高性能。\n\nReadWriteLock是接口，常用的实现类是ReentrantReadWriteLock 可重入读写锁。\n\n```java\npublic class Xxx {\n    public static ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); \n    public static ReentrantReadWriteLock.ReadLock readLock = lock.readLock();  //从读写锁获取读锁\n    public static ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();  //从读写锁获取写锁\n    //.....\n\n    public void a(){\n        //....\n\n        readLock.lock();\n        //..... 操作共享资源\n        readLock.unlock();\n        \n        //....\n    }\n\n}\n```\n读锁、写锁的操作方式和ReentrantLock完全相同，都可以设置超时，这3种锁都是可重入锁\n\n&nbsp;\n\n##### 锁降级\n在获取写锁后，写锁可以降级为读锁\n```java\npublic class Xxx {\n    public static ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); \n    public static ReentrantReadWriteLock.ReadLock readLock = lock.readLock();  //读锁\n    public static ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();  //写锁\n    //.....\n\n    public void a(){\n        //....\n\n        writeLock.lock();  //获取写锁\n        //..... 对共享资源进行写操作\n        readLock.lock();  //获取读锁（仍然持有写锁）\n        writeLock.unlock();  //释放写锁（只持有读锁，写锁->读锁，锁降级）\n        //.....  //对共享资源进行读操作\n        readLock.unlock();  //释放读锁\n        \n        //....\n    }\n\n}\n```\n- 锁降级后，线程仍然持有写锁，需要自己释放写锁\n- 锁降级的意义在于：后续对共享资源只进行读操作，及时释放写锁可以让其它线程也能获取到读锁、进行读操作\n- 锁降级的应用场景：对数据比较敏感，在修改数据之后，需要校验数据\n- 写锁可以降级为读锁，但读锁不能升级为写锁\n\n&nbsp;\n\n#####  AQS如何用int值表示读写状态\nAbstractQueuedSynchronizer，抽象类\n\nint，4字节32位，高位（前16位）表示读锁状态，低位（后16位）表示写锁状态。状态指的是重入次数，最大为2^16-1=65536\n\n&nbsp;\n\n#### StampedLock\nStampedLock是jdk1.8新增的类，可以获取读写锁、读锁、写锁，可以选择悲观锁、乐观锁，但StampedLock是不可重入的，且API比其他方式复杂，使用难度稍高。\n\n&nbsp;\n\n#### ThreadLocal\nThreadLocal维护了一个map，这个map中存储的数据是当前线程独有的。ThreadLocal可以保证各个线程的数据互不干扰，并发场景下可以实现无状态调用，适用于各个线程依赖不同的变量值完成操作的场景。\n\n```java\npublic class Xxx {\n    private static ThreadLocal<Integer> i = ThreadLocal.withInitial(() -> 100); //必须要初始化值\n\n    public void a() {\n        i.set(20);  //设置值\n        Integer value = i.get();  //获取值\n        i.remove();  //移出set()赋的值，重置为初始化时的值，即100\n    }\n\n}\n```\n\n&nbsp;\n\n#### volatile\n##### volatile的使用\n```java\npublic static volatile boolean flag = true;  //禁止对此变量进行指令重排序\n```\nvolatile只能修饰变量，实现了该变量的可见性、可以禁止指令重排序，当该变量的被某个线程修改时会自动通知其它使用此变量的线程。\n\nvolatile只实现了可见性，没有实现原子性，严格来说并没有实现线程安全，一般只用于\n- 作为开关 ，eg. while(flag){   }\n- 在懒汉式单例中修饰对象实例，禁止指令重排序\n\n&nbsp;\n\n##### volatile、synchronized的比较 \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608113420369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n&nbsp;\n\n#### 原子类\ni++、++i、i--、--i、+=、-=等操作都不是原子性的，juc的atomic包下的类提供了自增、自减、比较赋值、取值修改等原子性方法，可以线程安全地进行操作，因为类中的方法都是原子性的，所有叫做原子类。\n\n```java\npublic class Xxx {\n\n    public static AtomicInteger i = new AtomicInteger(0);  //int\n    public static AtomicLong l = new AtomicLong(0);  //long\n    public static AtomicBoolean b = new AtomicBoolean(false);  //boolean\n    public static AtomicReference<User> user = new AtomicReference<>(new User());  //引用\n\n    public static AtomicIntegerArray intArr = new AtomicIntegerArray(new int[]{1, 23});  //int[ ]\n    public static AtomicLongArray longArr = new AtomicLongArray(new long[]{1, 23});  //long[ ]\n\n    public static AtomicIntegerFieldUpdater<User> userId1 = AtomicIntegerFieldUpdater.newUpdater(User.class,\"id\");  //对象的int型字段\n    public static AtomicLongFieldUpdater<User> userId2 = AtomicLongFieldUpdater.newUpdater(User.class,\"id\");  //对象的long型字段\n    public static AtomicReferenceFieldUpdater<User, List>  userOrderList= AtomicReferenceFieldUpdater.newUpdater(User.class, List.class,\"orderList\");  //对象的引用型字段\n    \n}\n```\n- 原子类使用CAS实现乐观锁，并发支持好、效率高\n- CAS提交修改失败时会while循环进行重试，如果重试时间过长，会给cpu带来很大开销\n- 可能发生ABA问题。有2个原子类解决了ABA问题 ：AtomicMarkableReference、AtomicStampedReference，使用标记、邮戳实现乐观锁，和版本号、时间戳机制差不多，避免了ABA问题。\n- 只能保证单个变量的原子性，只能进行简单操作，如果要保证多个变量、稍微复杂点的操作的原子性，要用其它方式来实现线程安全（一般是加锁）\n&nbsp;\n\n#### 并发容器\nVector、Hashtable 的方法都使用synchronized修饰，是线程安全的，但缺点较多，基本不使用这2个类。\n\nCollections.synchronizedXxx()可以将集合转换为同步集合，是使用synchronized锁住整个集合，效率低下，不推荐。\n\njuc提供了常用的并发容器，使用CAS保证线程安全，效率高，常见的并发容器如下\n```java\nCopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();  //有序，按照插入顺序排列，内部使用Object[]存储元素\nCopyOnWriteArraySet<String> set = new CopyOnWriteArraySet<>(); //无序，CopyOnWriteArraySet内部使用CopyOnWriteArrayList存储元素\n\nConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();  //map\n\nConcurrentLinkedQueue<String> queue1 = new ConcurrentLinkedQueue<>();  //基于链表的队列\n\nLinkedBlockingQueue<String> queue2 = new LinkedBlockingQueue<>();  //基于链表的阻塞队列，如果参数指定了元素个数，则有界、不能扩容，如果未指定，则无界\n\nArrayBlockingQueue<String> queue3 = new ArrayBlockingQueue<>(20);  //基于数组的阻塞队列，指定容量，不能扩容（有界）\nArrayBlockingQueue<String> queue4 = new ArrayBlockingQueue<>(20,true);  //可以指定是否是公平锁，默认false\n```\n阻塞指的是，在进行某些操作时，会阻塞线程\n\n&nbsp;\n在生产者/消费者的线程协作模式中，常用阻塞队列LinkedBlockingQueue作为仓库\n```java\nLinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();  //基于链表的阻塞队列\n        \n//入队的3个方法\nqueue.offer(\"\");  //返会操作结果，boolean，如果队列满了放不下，返回false\nqueue.add(\"\");  //返会操作结果，boolean，如果队列满了放不下，会抛出异常\ntry {\n    queue.put(\"\");  //如果队列满了，会阻塞线程，直到队列元素变少、可以放进去\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n\n\n//出队的3个方法\nqueue.poll();  //如果队列是空的，返回null\nqueue.remove();  //如果队列是空的，会抛出异常\ntry {\n    queue.take();  //在队列为空的时候，会阻塞线程，直到有元素可弹出\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n&nbsp;\n\n### 并发工具类\n#### CountDownLatch\nCountDownLatch是一个计数器，常用于等待某些线程执行完毕\n```java\nCountDownLatch countDownLatch = new CountDownLatch(2);  //指定次数\n\nnew Thread(()->{\n    //.....\n    countDownLatch.countDown();  //次数-1\n}).start();\n\n\nnew Thread(()->{\n    //......\n    countDownLatch.countDown();\n}).start();\n\n\ntry {\n    countDownLatch.await();  //阻塞当前线程，直到次数为0时才继续往下执行，即等待2个线程执行完毕\n    //......\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n&nbsp;\n\n#### CyclicBarrier 栅栏\n```java\nCyclicBarrier cyclicBarrier = new CyclicBarrier(3);  //指定await的线程数\n\nnew Thread(()->{\n    //......\n    try {\n        cyclicBarrier.await();  //第一个\n        //.....\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } catch (BrokenBarrierException e) {\n        e.printStackTrace();\n    }\n}).start();\n\n\nnew Thread(()->{\n    //......\n    try {\n        cyclicBarrier.await();  //第二个\n        //.....\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } catch (BrokenBarrierException e) {\n        e.printStackTrace();\n    }\n}).start();\n\n\n//.....\ntry {\n    cyclicBarrier.await();  //第三个\n    //.....\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (BrokenBarrierException e) {\n    e.printStackTrace();\n}\n```\n线程执行到await()处会阻塞，停下来，直到指定数量的线程都执行到await()才会继续往下执行。\n\n CountDownLatch用于一些线程等待另一些线程执行完毕，类似超市收银员等待顾客挑好东西来结账；CyclicBarrier用于指定数量的线程互相等待，类似于大家指定地点集合。\n\n&nbsp;\n\n#### Semaphore 信号量\nSemaphore用于限流\n```java\nSemaphore semaphore = new Semaphore(2);  //指定信号量\n// Semaphore semaphore = new Semaphore(2,true);  //可指定是否使用公平锁，默认false\n\nnew Thread(() -> {\n    //......\n    try {\n        semaphore.acquire();  //使用1个信号量，信号量-1。如果信号量为0，没有可用的信号量，阻塞线程直到获取到信号量\n        //....\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } finally {\n        semaphore.release();  //操作完释放信号量，信号量+1\n    }\n}).start();\n```\n\n&nbsp;\n\n#### Exchanger\n交换机，用于2条线程之间交换数据，只能用于2条线程之间，即一个Exchanger对象只能被2条线程使用（成对）\n```java\nExchanger<String> stringExchanger = new Exchanger<>();  //泛型指定交换的数据类型\n\nnew Thread(()->{\n    try {\n        String data = stringExchanger.exchange(\"are you ok？\");\n        System.out.println(\"线程1接收到的数据：\" + data);  //ok\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}).start();\n\nnew Thread(()->{\n    try {\n        String data = stringExchanger.exchange(\"ok\");\n        System.out.println(\"线程2接收到的数据：\" + data);  //are you ok\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}).start();\n```\n\n&nbsp;\n\n### 单例与线程安全\n单例有2种模式\n- 饿汉式：在类加载时就实例化，线程安全\n- 懒汉式：在需要使用实例时才实例化，可能是线程不安全的\n\n&nbsp;\n**饿汉式**\n```java\n//饿汉式\npublic class A {\n    private static A a=new A();  //用静态成员保存实例，调用构造方法创建实例。类加载时会初始化静态成员\n    //.....  \n\n    private A(){  //构造方法私有化，隐藏掉\n\n    }\n\n    public static A getInstance(){  //把获取实例的方法暴露出去\n        return a;  //只有1步，原子性，线程安全\n    }\n\n    //.....  \n}\n```\n\n&nbsp;\n\n**懒汉式**\n```java\n//懒汉式  写法一\nclass A {\n    private static A a;  //用静态成员保存实例\n    //.....   \n\n    private A(){  //构造方法私有化，隐藏掉\n\n    }\n\n    public static A getInstance(){  //暴露获取实例的方法，多步，不具有原子性，不是线程安全的\n        if (null==a){  \n            a = new A();  \n        }\n        return a;\n    }\n\n    //.....   \n\n}\n```\n&nbsp;\n写法二：用synchronized修饰获取获取实例的静态方法，但这种方式获取实例时会锁住类，使多个线程不能同时获取实例，效率低下\n&nbsp;\n```java\n//懒汉式  写法三\nclass A {\n    private static volatile A a;  //volatile禁止指令重排序\n    //.....   \n\n    private A(){\n\n    }\n\n    public static A getInstance(){\n        if (null==a){\n            synchronized (A.class){  //优化写法，只在创建实例时锁住类\n                a = new A();\n            }\n        }\n        return a;\n    }\n\n    //.....  \n\n}\n```\n\n&nbsp;\n\n### 锁的分类\n- 自旋锁：未获取到锁时进入等待状态，多线程切换上下文会消耗系统资源，频繁切换上下文不值得，jvm会在线程没获取到锁时，暂时执行空循环等待获取锁，即自旋，循环次数即自旋次数；如果在指定自旋次数内没获取到锁，则挂起线程，切换上下文，执行其它线程。锁默认是自旋的。\n\n- 自适应自旋锁：自旋次数不固定，由上一次获取该锁的自旋时间及锁持有者的状态决定，更加智能\n&nbsp;\n- 阻塞锁：阻塞锁会改变线程的运行状态，让线程进入阻塞状态进行等待，当获得相应信号（唤醒或阻塞时间结束）时，进入就绪状态\n&nbsp;\n\n- 重入锁：已持有锁的线程，在未释放锁时，可以再次获取到该锁\n```java\npublic class Xxx{\n    public final static ReentrantLock lock=new ReentrantLock();\n\n    public void a() {\n        lock.lock();\n        //.....\n        b();  //如果锁是可重入的，则b()直接获取到锁；如果锁不是可重入的，则b()需要单独获取获取锁，但锁还没被a()释放，b()会一直获取不到锁\n        //.....\n        lock.unlock();\n    }\n\n    public void b() {\n        lock.lock();\n        //......\n        lock.unlock();\n    }\n\n}\n```\n\n&nbsp;\n\n- 读锁：是一种共享锁 | S锁（share），多条线程可同时操作共享资源，但都只能进行读操作、不能进行写操作\n\n- 写锁：是一种排它锁 | 互斥锁 | 独占锁 | X锁，同一时刻最多只能有1个线程可以对共享资源进行写操作，其它线程不能对该资源进行读写\n&nbsp;\n\n- 悲观锁：每次操作共享资源时，认为期间其它线程一定会修改共享资源，每次操作共享数据之前，都要给共享资源加锁\n\n- 乐观锁：每次操作共享资源时，认为期间其它线程一般不会修改共享资源，操作共享资源时不给共享资源加锁，只在提交修改时验证数据是否被其它线程修改过，常用版本号等方式实现乐观锁\n&nbsp;\n\n- 公平锁：等待锁的线程按照先来先得顺序获取锁（慎用）\n- 非公平锁：释放锁后，等待锁的线程都可能获取到锁，不是先来先得\n\n非公平锁可能导致某些线程长时间甚至一直获取不到锁，但这种情况毕竟是极少数；使用公平锁，为保证公平性有额外的开销，会降低性能，所以一般使用非公平锁\n&nbsp;\n\n- 偏向锁：初次获取锁后，锁进入偏向模式，当获取过锁的线程再次获取该锁时会简化获取锁的流程，即锁偏向于曾经获取过它的线程\n\n&nbsp;\n\n锁消除：编译时会扫描上下文，自动去除不可能存在线程竞争的锁\n\n锁细化：如果只操作共享资源的一部分，不用给整个共享资源加锁，只需给要操作的部分加锁即可。使用细粒度的锁可以让多个线程同时操作共享资源的不同部分，提高效率。\n\n锁粗化：要操作共享资源的多个部分，如果每次只给部分加锁，频繁加锁、释放锁会影响性能，可以扩大锁的作用范围，给整个共享资源加锁，避免频繁加锁带来的开销。\n\n&nbsp;\n\n### 指令重排序\n指令重排序：编译器、处理器会对指令序列重新排序，提高执行效率、优化程序性能\n```java\nint a=1;\nint b=1;\n```\n以上2条指令会被重排序，可能2条指令并发执行，可能int a=1;先执行，可能int b=1;先执行。\n&nbsp;\n\n**指令重排序遵循的2个原则**\n\n1、 数据依赖性，不改变存在数据依赖关系的两个操作的执行顺序。\n```java\nint a=1;\nint b=a;\n```\nb依赖于a，重排序不能改变这2个语句的执行顺序\n&nbsp;\n\n2、as-if-serial原则，重排序不能改变单条线程的执行结果\n```java\nint a=1;\nint b=a;\n```\n执行结果是a=1、b=1，重排序后执行得到的也要是这个结果\n\n&nbsp;\n\n### 数据同步接口\n有时候需要对接第三方的项目，或者公司大部门之间对接业务，不能直接连接、操作他们的数据库，一般是建中间库|中间表，把我们|他们需要的数据放到中间库|表中，去中间库|表获取数据。更新数据库时需要同步更新中间库|表。\n&nbsp;\n\n**中间表的设计**\n- 只存储要使用的字段即可\n- 需要用一个字段记录该条数据的状态：已入库、正在处理、处理时发生异常、已处理\n- 需要用一个字段记录数据入库时间\n- 需要用一个字段记录处理时间\n\n记录时间是为了日后好排查问题、统计分析\n\n&nbsp;\n\n**对中间表的处理**\n\n可以使用生产者/消费者的线程协作模式\n- 生产者分批读取中间表中未处理的数据  where status=\'xxx\'，放到仓库中。因为数据量一般很大，所以通常要分批读取，防止仓库装不下。如果要操作多张表，很多操作都差不多，可以抽象出接口\n- 消费者处理仓库中的数据\n\n操作时需要更新中间表中的数据状态、处理时间', 26, '多线程', '线程安全', 1, 0, 0, 0, '2020-06-27 19:23:01', '2020-06-27 19:23:01');
INSERT INTO `tb_blog` VALUES (9, '分布式系统的CAP理论', '', 'http://127.0.0.1:9501/admin/dist/img/rand/33.jpg', '\n### CAP定理（理论）\n在一个分布式系统中，\n- Consistency（数据一致性）\n- Availability（服务可用性）\n- Partition tolerance（分区容错性）\n\n三者不可兼得，最多只能同时满足两点，没法三者兼顾。\n\n&nbsp;\n\n### 一致性(Consistency)  \n分布式系统中的数据，在同一时刻是否一致。常见的体现是，集群中的从节点数据是否和主节点的一致。\n\neg. 数据库主库写，从库读，用户完成支付再查询订单状态，主库执行写操作把订单状态改为了已支付，从从库查询订单状态时要是已支付，数据要是一致的、同步的。\n &nbsp;\n\n**强一致性（strong consistency）**\n\n任何时刻，所有用户都能读取到最近一次成功更新的数据，即所有用户读取到的数据都是最新的。\n\n优点： 数据一致，数据不会出错；缺点： 效率低下。\n &nbsp;\n \n **弱一致性（weak consistency）**\n \n用户不一定能读取到最新的数据。\n&nbsp;\n\n**最终一致性（eventual consistency）**\n\n不能保证用户读取到的是最新的数据，但会用一些方式使数据最终一致。\n\n&nbsp;\n\n### 可用性(Availablity)\n系统负载过大时，是否还能处理、响应请求，eg. 原来qps（每秒访问量）是1000，现在飙到10000，系统依然扛得住、可用。\n\n可用指的是在正常时间范围内处理完每个请求，不管是让请求快速失败、还是服务降级，都算可用。\n\n&nbsp;\n\n### 分区容错性(Partition-torlerance)\n即高可用，一个节点崩溃、故障，其它节点不受影响。\n\n常见的做法是增加机器数量，做集群，少数节点挂掉，集群整体依然可用。\n\n集群节点越多，分区容错性越强，但完成节点间数据同步所需的时间也越长，节点IO压力大，数据一致性越得不到保证（越差）。\n\n&nbsp;\n\n### 情况分析\n**满足AC，不满足p**\n\n满足A=>在指定时间内处理完请求，满足C=>完成节点间的数据同步\n\n要在指定时间内处理完请求、并完成数据同步，那集群节点就得少，节点多了同步要花大量时间、时间不够，集群节点少所以不满足P。\n\n &nbsp; \n\n**满足CP，不满足A**\n\n满足C=>保证数据同步的时间开销，满足P=>集群节点多\n\n节点又多、还要等这些节点都完成数据同步，那就不能保证在正常时间范围内处理完请求，所以不满足A。\n\n&nbsp;\n\n**满足AP，不满足C**\n\n满足A=>指定时间内处理完请求，满足P=>集群节点多\n\n节点又多、还要在指定时间范围内处理完请求，那集群节点之间的数据同步就得不到保证，所以不满足C。\n\n&nbsp;\n\n### 总结 \n一台机器肯定是不行的，一旦该机器发生什么故障，系统就瘫痪了，都要做集群保证分区容错性（P，高可用），所以往往是在A、C之间取舍。\n&nbsp;\n\nZK保证了数据一致性（C），但选举新的leader时集群不能对外提供服务，不满足可用性（A）。\n\nEureka是去中心化的，集群中每个节点的地位一样，一个节点挂了，其它节点不受影响，依然能对外提供服务，保证了可用性（A），但每个节点都需要从其它所有的节点同步数据，容易受网络故障影响，不满足数据一致性（C）。\n&nbsp;\n\n选择注册中心时，看项目对A、C的需求哪个更高\n\n- 对C要求高的，比如银行的项目都涉及钱，优先选择ZK。负载大了大不了用户访问不了，钱好歹没有问题、账目是对的（数据一致）。\n\n- 对A要求高的，比如大学选课系统，高考、四六级查分，电商系统，负载大时依然要扛得住、可用，优先选Eureka。\n\n', 27, '分布式', 'CAP理论', 1, 0, 0, 0, '2020-06-27 19:27:00', '2020-06-27 19:27:00');
INSERT INTO `tb_blog` VALUES (10, '幂等性', '', 'http://127.0.0.1:9501/admin/dist/img/rand/34.jpg', '\n### 幂等性的概念\n对于同一操作发起的请求，执行多次对资源本身产生的影响与执行一次相同，不会因为多次相同操作而产生副作用。\n\neg. 用户注册，点击提交，由于某些原因（比如服务器负载大），长时间转圈圈，用户不耐烦疯狂点提交按钮，发起了多次相同的请求，最终应该只插入一条用户记录，而不是点几次提交就插入几条用户记录。\n\neg. 双11下单，点提交，卡了，什么破手机|网络，疯狂点提交，虽然发起了多次请求，但多次发起的请求都完全相同，最终应该只产生一个订单，而不是每次点提交都产生一个订单。\n\n&nbsp;\n\n### 消息中间件与幂等性\n消息消费者经常要实现幂等性，保证消费者不重复消费同一消息。\n\neg. rabbitmq为保证消息的可靠性投递，往往要延时再次投递消息进行确认，需要在消息消费者中实现幂等性，如果之前已消费了同样的消息，就不再消费该消息。\n\n消息消费者需不需要实现幂等性，视业务需求而定，看对于同一消息是否要重复消费。\n\n&nbsp;\n\n### http请求方式与幂等性\n请求方式 | 应用 | 是否幂等\n:-- | :-- | :-- \nGET | 获取资源 | 幂等，查询一次或多次，结果相同\nPOST | 创建资源 | 非幂等，eg. 主键自增，多次插入相同的用户记录，是会增加多条记录的\nPUT | 更新资源 | 幂等，eg. 把name字段修改为chy，不管执行1次或多次，这个资源结果都是name=chy \nDELETE | 删除资源 | 幂等，不管删除多少次，这个资源结果都是没了\n\n&nbsp;\n\n### 实现幂等性的常见方式\n#### 核心思想\n使用唯一的业务单号来标识一个业务，存储执行过的业务的业务单号，先根据业务单号查询这笔业务是否已经执行过了，如果没执行过，才执行。（去掉重复的业务）\n\n业务单号可以用自增的流水号，也可以使用唯一id+指纹码，总之要能唯一标识一笔业务。\n\neg. 订单id可以唯一标识一个订单，但不能标识是这个订单的哪个业务，是增改删查中哪个操作？第几次操作？标识不了，需要再加一个指纹码，比如时间戳、业务规则。\n &nbsp;\n \n#### 1、数据库主键去重\n单独用一张表存储处理过的业务的业务单号，把业务单号作为主键（unique）。\n\n执行业务时先查数据表有没有该业务单号，有就说明该业务已处理过，不再处理，没有就说明该业务未处理过，开始处理。\n\n缺点：增加了数据库IO次数，数据库操作是很耗时的，数据库性能容易成为系统性能的瓶颈。\n\n&nbsp;\n\n#### 2、分布式锁（推荐）\n处理业务时先setnx把业务单号作为key存储在redis上，返回1说明没有这个key、设置成功，开始处理业务；返回0说明这个key已存在（已处理过该业务）、设置失败，不再处理。处理业务失败时应该删除对应的key。\n\n', 27, '分布式', '幂等性', 1, 0, 0, 0, '2020-06-27 19:28:07', '2020-06-27 19:28:07');
INSERT INTO `tb_blog` VALUES (11, 'JVM 架构、运行时数据区', '', 'http://127.0.0.1:9501/admin/dist/img/rand/7.jpg', '\n### jvm架构\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200522164436940.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n\n- 类加载器：加载.class文件到内存，创建对应的class对象\n- 执行引擎：对命令进行解析\n- 本地方法库：融合不同开发语言的原生库为java所用\n- 运行时数据区：包含方法区、堆、程序计数器、java虚拟机栈、本地方法栈\n\n运行时数据区也叫作jvm内存模型，JVM Memory Model，JMM。\n&nbsp;\n\n线程共享数据区：方法区、堆，所有线程共享；\n线程隔离数据区：程序计数器、java虚拟机栈、本地方法栈，线程独有，生命周期与所在线程的生命周期一致\n&nbsp;\n\n上图只是jvm的规范，不同种类的jvm实现可能有差异。\n\nHotSpot jdk8以前用永久代（PermGen）实现方法区，并把永久代放到堆中，作为堆的一部分，使用堆内存，受堆内存大小限制；jdk8及以后使用元空间（MetaSpace）实现方法区，使用本地内存，不使用堆内存，受本地内存（机器内存）限制。\n\n&nbsp;\n\n### jvm运行时数据区\n#### 程序计数器\n程序计数器占用很小的一块内存空间，每条线程都有1个程序计数器，用来记录当前线程的执行到的位置\n\n线程是一个独立的执行单元，由CPU控制执行，当前线程的时间片用完之后，程序计数器记录执行到的位置，重新获取时间片后，恢复到该位置，从该位置继续往下执行。\n\n&nbsp;\n\n#### java虚拟机栈\njava虚拟机栈用于方法执行。\n\njvm执行每个方法时都会创建一个栈帧（Stack Framel），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法调用到执行完毕，对应栈帧在java虚拟机栈中入栈到出栈的过程。\n\n局部变量表存储编译期可知的局部变量，如果是局部变量是对象，则存储该对象的引用。\n\n```java\n public void a(){\n\n }\n\n public void b{\n     a();\n }\n```\nb()的执行流程:\n- 先创建b的栈帧，b的栈帧入栈\n- 执行到调用a()时，先创建a的栈帧，a的栈帧入栈\n- a()执行完毕=>a的栈帧出栈，执行b的栈帧\n- b()执行完毕，b的栈帧出栈\n\njava虚拟机栈，栈，先进后出\n\n如果递归调用、且递归没有出口，则执行时会给递归方法创建无数栈帧，java虚拟栈内存耗尽，最终栈溢出，抛出 StackOverflowError 异常。\n\n&nbsp;\n\n#### 本地方法栈\n本地方法栈和java虚拟机栈差不多，区别是：\n- java虚拟机栈用于执行java语言编写的方法\n- 本地方法栈用于执行本地方法（native方法），native方法就是用其它语言编写的方法，比如c、c++写的，因为用关键字native修饰，所以叫做native方法\n\n&nbsp;\n\n#### 方法区\n方法区用于存储已加载的类的信息、常量、静态变量等。\n\n&nbsp;\n\n##### 方法区之常量池\n常量池是方法区的一部分，加载类的class对象后，该class对象的字面量、符号引用存储在方法区的常量池中。\n\n```java\nString str1=\"hello\";\nString str2=\"hello\";\n\nString str3=new String(\"hello\");\nString str4=new String(\"hello\");\n\nSystem.out.println(str1==str2);  //true\nSystem.out.println(str3==str4);  //false\nSystem.out.println(str1==str3);  //false\n```\n常量池使用HashSet存储数据，没有重复的数据（常量）。\n创建str2时，常量池中已经有了\"hello\"，str2直接指向这个已存在的常量，str1==str2；\n\nstr3、str4都是new出来的，new出来的是对象，对象存储在堆中，每次new都是重新分配内存空间。str1是常量池中的常量，str3是堆中的对象，不相等；str3、str4都是堆中的对象，但地址不同，不相等。\n\n&nbsp;\n\n**==与equals()**\n\n==，如果是基本数据类型、\"\"的String，根据值（内容）来比较；如果是引用类型（包括new出来的String），根据对象地址来比较；如果一个是前者，一个是后者，自然不等。\n&nbsp;\n\nequals()，根类Object的equals()和\\=\\=完全等价，因为本来就是使用==来判断\n```java\n// Object类的equals()源码\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n但jdk自带的类基本都重写了equals()、hashCode()，equals()根据内容来比较，我们自定义的类，如果没有继承jdk自带的类、没有重写equals()，那equals()就是继承Object的，和\\=\\=等价。\n\n&nbsp;\n\n#### 堆\n堆是jvm中最大的一块内存，是垃圾收集器管理的主要区域，几乎所有的数组、对象都在堆中分配。\n\n&nbsp;\n\n### jvm三大性能调优参数\n```bash\n#控制台打印gc信息，多个参数空格隔开\n-verbose:gc -XX:+PrintGCDetails\n\n\n#jvm三大性能调优参数，单位可以直接写，k、m、g\n-Xss256k  #指定每个线程java虚拟机栈的大小，一般设置为256k\n-Xms512m  #指定堆的初始大小\n-Xmx512m  #指定堆的最大体积\n#一般将堆初始大小、最大体积设置为一样的，防止堆扩容时引起内存抖动、影响程序运行的稳定性\n\n\n#执行jar包时可以设置jvm参数\njava -Xms512m -Xmx512m -jar xxx.jar &\n```\n最大堆内存不是越大越好，堆内存越大Full GC回收垃圾花费的时间越长，系统停顿时间越长。解决方案是集群，分担压力，每个服务器的最大堆内存就不用设置太大，可以缩短Full GC引起的系统停顿时间。\n\n&nbsp;\n\n### 堆、栈（java虚拟机栈）的区别\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200604183801855.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n\n\n\n\n\n\n\n\n\n\n\n\n', 28, 'JVM', 'jvm架构', 1, 0, 0, 0, '2020-06-27 19:30:27', '2020-06-27 19:30:27');
INSERT INTO `tb_blog` VALUES (12, 'JVM 类加载机制、对象的创建过程', '', 'http://127.0.0.1:9501/admin/dist/img/rand/17.jpg', '\n### 类加载机制\n类加载也叫类初始化，包括加载、连接、初始化三个步骤。\n&nbsp;\n\n#### 加载\njvm将类的.class文件读到内存中，并创建对应的java.lang.Class对象。\n&nbsp;\n\n**加载由类加载器来完成，jvm提供了3种类加载器**\n- Bootstrap  ClassLoader ：根类加载器，也叫做引导类加载器，负责加载jdk中的核心类。根类加载器是用C++写的，不继承java.lang.ClassLoader。\n- Extension  ClassLoader ：扩展类加载器，负责加载jdk中的扩展类（非核心类），扩展类加载器是用java写的，继承自ClassLoader。\n- System  ClassLoader：系统类加载器，负责加载第三方jar包、我们自己写的类。系统类加载器是用java写的，继承自ClassLoader。\n\n可以继承ClassLoader类来实现自定义的类加载器。\n \n加载顺序：根类加载器、扩展类加载器、系统类加载器、自定义的类加载器\n\n&nbsp;\n\n**jvm的类加载机制有3种，这3种机制共同作用，一起完成类的加载**\n\n- 全盘负责：使用类加载器加载一个类时，这个类所依赖（引用）的类也由该类加载器加载\n- 父类委托：先使用父类的类加载器来加载，如果父类的类加载器加载不了，再使用类本身的类加载器来加载\n- 缓存机制：jvm会缓存加载过的类的class对象，要使用某个类时，先在缓存中搜索是否有对应的class对象，有就直接使用、不再加载，没有才加载。运行程序后，如果修改了某个类，需要重启jvm才会生效，不然使用的是之前缓存的class对象。\n\n&nbsp;\n\n**类加载的大致过程**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602230710722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n类加载是按需加载，使用该类时才加载，类加载生成的class对象用全类名唯一标识。\n\n因为存在缓存机制，一个类只加载一次，且一个类在内存中最多只有一个class对象。\n&nbsp;\n\n**为什么要使用双亲委派机制去加载类？**\n\n避免重复加载同一个.class文件\n\n&nbsp;\n\n#### 连接\n加载获得的class对象是二进制数据，连接是把class对象放到jre中（把class对象连接到jre），jre即java运行时环境。\n&nbsp;\n\n**连接分为3个阶段**\n- 校验：检验被加载的类的内部结构是否正确、和其他类是否协调一致\n- 准备：为类的成员变量分配内存，设置默认的初始值，比如int赋为0，引用型赋为null\n- 解析：将class对象中的符号引用替换为直接引用\n\nclass对象是加载时生成的，加载时class对象中的成员变量还没有分配内存，不知道该成员变量在内存中的地址，只能用符号引用暂时表示该成员变量在内存中的地址。连接的准备阶段给成员变量分配内存，之后就可以用直接引用（内存地址）替换掉符号引用。\n \n&nbsp;\n\n#### 初始化\n初始化是对类进行初始化，不是对类的对象进行初始化。类初始化会执行static代码块、初始化static静态成员。\n\n&nbsp;\n\n#### 类加载|初始化的时机（jvm什么时候加载|初始化一个类）\n- 创建类的实例。包括通过new来创建、通过反射来创建、通过反序列化来创建。\n- 通过类名调用类的静态成员\n- 初始化这个类的子类之前\n- 通过java.exe运行主类时，JVM会先初始化这个主类，再执行这个主类\n\n&nbsp;\n\n#### 类加载方式\n**主要有两种**\n- 隐式加载：使用new创建对象，隐式调用类加载器，加载对应的类到 JVM 中，这是最常见的类加载方式\n- 显式加载：使用 loadClass()、forName() 等方法显式加载需要的类，获取到 Class 对象后，调用 Class 对象的 newInstance() 方法来创建类的实例\n\n&nbsp;\n\n**两种类加载方式的区别**\n- 隐式加载能直接获取类的实例，显式加载需要调用 Class 对象的 newInstance() 方法来生成类的实例\n- 隐式加载能使用带参的构造函数，而Class对象的 newInstance() 不能传入参数，如果要使用带参的构造函数，可以通过反射获取到该类带参的构造方法，通过反射调用带参的构造方法来创建实例\n\n&nbsp;\n\n**loadClass() 、 forName() 的区别**\n\nloadClass() 只执行类加载的第一步：加载，后续操作均未进行；Class.forName() 执行了类加载的整个过程（3步）。\n\n&nbsp;\n\n### 对象的创建过程\n1、先在常量池中定位该类的符号引用，判断是否已有该类的class对象，如果没有则先加载该类。加载时会执行static代码块、初始化静态成员\n&nbsp;\n\n2、在堆中分配内存空间。有2种分配方式\n- 指针碰撞：适用于连续的内存空间，包括开辟一块内存、移动指针两个步骤\n- 空闲列表：适用于琐碎的内存空间，包括开辟一块内存、修改空闲列表两个步骤\n\n都是2个步骤，不具有原子性，可能出现并发问题，jvm采用CAS算法实现乐观锁，搭配失败重试来保证内存分配的成功率。\n&nbsp;\n\n3、初始化分配的内存空间。分配内存空间时是按成员变量的类型进行分配的，此时初始化成员变量为默认值，比如int型初始化为0，引用型初始化为null\n&nbsp;\n\n4、设置对象头的相关数据，比如GC分代年龄、对象的hashCode、锁状态标识、元数据信息\n&nbsp;\n\n5、执行普通初始块、构造函数\n\n&nbsp;\n\n### 对象的内存布局\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200522224014703.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n1、对象头用于存储对象的元数据信息\n- Mark Word 部分存储对象自身的运行时数据，比如哈希值、gc分代年龄、锁状态标识\n- 类型指针指向对象所属的类的元数据，标识对象所属的类\n\n2、实例数据存储的是对象本身的数据，即各成员变量的值\n\n3、对齐填充部分只是让实例数据占用的内存空间是8的倍数，无实际意义\n\n&nbsp;\n\n### 对象的访问方式\n对象创建之后，在java虚拟机栈中进行访问，有2种访问方式\n- 直接指针访问：虚拟机栈的局部变量表中存储对象的引用（reference类型），通过引用直接访问对象\n- 句柄访问：用句柄存储对象的引用，句柄放在句柄池中，虚拟机栈的局部变量表中存储对象的句柄，相当于二级指针。句柄池是堆中的一块内存。\n\n直接指针访问效率高，但gc回收对象时效率低；句柄访问效率低，但gc回收对象时效率高。HotSpot虚拟机采用的是直接指针访问。\n\n', 28, 'JVM', 'jvm类加载机制', 1, 0, 0, 0, '2020-06-27 19:31:17', '2020-06-27 19:31:17');
INSERT INTO `tb_blog` VALUES (13, 'JVM垃圾回收机制', '', 'http://127.0.0.1:9501/admin/dist/img/rand/13.jpg', '\n\nC++的内存回收很麻烦，不回收可能会造成内存泄漏，Java中由GC完成内存回收，不用手动回收内存。堆是垃圾回收的重点区域。\n&nbsp;\n\n### 判断对象是否为垃圾（存活）的算法（2种）\n对象被判定为垃圾的标准：没有被其它对象引用\n&nbsp;\n\n#### 引用计数算法\n堆中每个对象都对应一个引用计数器，当一个变量引用这个对象时，计数器+1；当引用这个对象的变量生命周期结束或者被赋新值时，计数器-1；如果对象的计数器为0，该对象就成为垃圾，等待gc回收。\n&nbsp;\n\n优点：简单、高效；缺点：无法检测出循环引用，可能会导致内存泄漏。\n\neg. a对象中引用了b对象，b对象中引用了a对象，即循环引用，如果使用引用计数法，这2个对象的计数器永不为0，即使把这2个对象都置为null，它们的计数器也不为0，永远不会被回收。\n\n由于这个原因，主流垃圾收集器都不采用引用计数算法，而采用可达性分析算法\n\n&nbsp;\n\n#### 可达性分析算法（主流）\n又叫做根搜索算法，使用不同的GC Root，从GC Root开始寻找引用链上的对象，没在任何一条引用链中的对象即成为垃圾，等待gc回收。\n&nbsp;\n可以作为GC Root的对象\n- java虚拟机栈中引用的对象（本地变量表）\n- 本地方法栈中引用的对象\n- 方法区中静态成员引用的对象\n- 方法区中常量引用的对象\n\n&nbsp;\n\n### 垃圾回收算法（4种）\n#### 标记-清除算法\n标记-清除（Mark-Sweep）算法是最基础的垃圾回收算法，分为标记、清除两个阶段：①先标记出所有需要回收的对象（使用判断对象是否存活的算法进行标记），②标记完成后统一回收所有被标记的对象。\n&nbsp;\n缺点：会产生大量内存碎片，可能导致后续没有足够大的连续内存来分配大对象，从而提前触发下一次垃圾回收。\n\n&nbsp;\n\n#### 标记-整理算法\n标记-整理（Mark- Compact）算法：①使用可达性分析算法进行标记，②将所有存活的对象移动到内存的一端，然后直接清理掉边界以外的内存。\n\n&nbsp;\n\n#### 复制算法\n复制（Coping）算法：将内存划分为对象面、空闲面，在对象面创建对象，垃圾回收时将存活的对象复制到空闲面，一次性清理掉对象面上的所有对象。\n\n不会产生内存碎片，适合对象存活率低的场景。\n\n&nbsp;\n\n#### 分代收集算法（主流）\n分代收集算法：按照对象生命周期的不同将堆划分为不同区域，各区域采用合适的垃圾回收算法。\n&nbsp;\n\n##### 堆内存的划分\n把堆划分为2大块\n- 新生代（Young Gen）：包括Eden区、2个Survivor区（from、to），默认大小比例8:1:1。\n- 老年代（Old Gen）\n\n新生代使用复制算法进行垃圾回收：回收时把Eden区、Survivor from区中存活的对象复制到Survivor to中，然后一次性清理Eden区、Survivor from区。\n\n老年代使用标记清除算法或标记整理算法进行垃圾回收，不同的垃圾收集器，老年代使用的垃圾回收算法可能不同。\n\n&nbsp;\n\n##### 对象的分配规则\n- 对象主要分配在新生代的 Eden 区上\n- 如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配\n- 少数情况下会直接分配在老年代中，比如大对象\n\n&nbsp;\n\n##### Minor GC、Full GC\n新生代 GC (Minor GC）：发生在新生代的垃圾收集动作，新生代对象回收率通常高达98%，Minor GC 非常频繁。\n\n老年代 GC (Major GC | Full GC）：发生在老年代的垃圾收集动作，老年代内存大、对象多，这导致了回收速度慢，Full GC的时间开销一般是 Minor GC 的10 倍以上。\n\n&nbsp;\n\n##### 触发Full GC的条件\n- 调用System.gc()。虽然只是建议进行Full GC，但一般都会进行\n- 老年代空间不足\n- 新生代空间不足时会使用老年代的内存空间担保，如果出现担保失败( Promotion Failure )，会触发 Full GC\n\nFull GC时间开销大，频繁Full GC会拉低性能，应该避免频繁Full FC，看到jvm频繁Full GC时要引起注意。\n\n&nbsp;\n\n##### 对象如何晋升到老年代\n- 经历一定Minor GC次数仍然存活。每经历一次Minor GC还存活就将该对象的年龄+1，年龄达到指定值（默认15）时就放到老年代中\n- 如果新生代对象存活率偏高，Survivor to中放不下，会使用老年代的空间进行分配担保（Handle Promotion），即把Survivor to放不下的对象直接放到老年代中\n- 大对象直接在老年代进行分配（老年代内存空间比新生代大得多）\n\n&nbsp;\n\n##### 常用的jvm参数\n```bash\n-Xmn512m  #指定Eden区大小\n\n-Xx:SurvivorRatio=8  #Eden区与一个Servivor区的大小比例，默认8，2个servivor区默认1:1\n\n-Xx:NewRatio=3  #老年代、新生代的大小比例，默认3:1\n\n-XX:PretenureSizeThreshold=3145728  #大对象阈值，单位字节，对象体积超过这个值就认为是大对象，直接在老年代分配，否则在Eden区分配\n\n-XX:MaxTenuringThreshold=15  #新生代对象晋升到老年代需经历的Minor GC次数，即对象的年龄\n```\n\n&nbsp;\n\n### JVM垃圾收集器\n垃圾回收算法相当于接口，定义了垃圾回收的大致流程、步骤，垃圾收集器是垃圾回收算法的具体实现。\n\nstop the word：jvm执行gc时会暂停应用程序的执行，gc完成才会继续执行应用程序，每种垃圾收集器都存在这个问题。gc优化一般是减少gc引起的系统停顿时间。\n\nsafepoint：安全点，垃圾标记过程中对象引用关系不会发生变化的点，比如方法调用、循环跳转处。\n\n&nbsp;\n\n#### JVM的2种运行模式\n- server模式：使用重量级虚拟机，启动慢，但做了更多的优化，稳定运行后性能更高，适合对性能要求高的项目，常用于web项目\n- client模式：使用轻量级虚拟机，适合对性能要求不高的项目，常用于桌面项目，因为桌面项目内存占用小，一般就几十几百兆\n\n使用java -version可以看到jvm的种类、运行模式，HotSpot默认的运行模式是Server。\n\n&nbsp;\n\n#### 新生代常见的收集器（3种）\n##### Serial收集器\n使用复制算法，单线程，垃圾回收过程如下\n- 触发gc、暂停所有用户线程\n- Serial启动一个线程进行垃圾回收（单线程）\n- 垃圾回收完毕，所有用户线程继续执行\n\nSerial性能低，常用于桌面程序，是client模式下默认的垃圾收集器\n\n&nbsp;\n\n##### ParNew收集器（主流）\n使用复制算法，相当于Serial的多线程版本，进行垃圾回收时会启动多个线程进行垃圾回收。单核执行效率不如Serial，在多核下才有优势。\n\n```bash\n#使用ParNew收集器，+是使用，如果要取消默认的收集器，收集器名字前加-\n-XX:+UseParNewGC\n\n#可以指定进行垃圾回收的线程数，默认为cpu核心数，一般也是使用cpu核心数\n-XX:ParallelGCThreads=8\n```\nParNew是新生代首选的收集器，很大的一个原因是目前只有Serial、ParNew可以和CMS搭配使用\n\n&nbsp;\n\n##### Parallel Scavenge收集器（默认）\n使用复制算法，多线程，吞吐量优先，是Server模式下默认的是新生代收集器。\n&nbsp;\n与其他收集器不同，其它收集器关注缩短系统停顿时间，而 Parallel Scavenge关注吞吐量。吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间），高吞吐量可以高效利用 CPU 时间，尽快执行完程序任务，适合在后台进行、不需要太多交互的任务。\n&nbsp;\n\nParallel Scavenge可以使用gc自适应调节：JVM根据系统当前的运行情况，动态调整参数设置最适合的gc停顿时间、吞吐量。\n\n```bash\n#使用gc自适应调节，自动调整、设置gc停顿时间、吞吐量\n-XX:UseAdaptiveSizePolicy\n\n\n#也可以手动设置，但一般不手动设置\n\n#设置gc最大暂停时间，在这个时间范围内，至少进行一次gc\n-XX:MaxGCPauseMillis=600000\n#设置吞吐量，默认99，即吞吐量为99%\n-XX:GCTimeRatio=99\n```\n\n&nbsp;\n\n#### 老年代常见的收集器（3种）\n##### Serial Old\n和Serial差不多，只不过是以标记整理算法，用于收集老年代，是client模式下默认的老年代收集器\n\n&nbsp;\n\n##### Parallel Old（默认）\n多线程，使用标记整理算法，吞吐量优先，Server模式下默认的老年代收集器\n\n```bash\n#取消默认的Parallel Old收集器\n-XX:-UseParallelOldGC\n```\n\n&nbsp;\n\n##### CMS收集器（主流）\n以系统最短停顿时间为目标，使用标记清除算法\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060109272842.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n- 初始标记 ：标记作为GC Root的对象\n- 并发标记：根据可达性分析算法找出所有的引用链\n- 重新标记：修正并发标记期间因用户程序导致的标记变动\n- 并发清除：回收标记对象\n&nbsp;\n\njava web项目作为服务端，重视响应速度，希望gc引起的系统停顿时间最短，以带给用户较好的体验。CMS回收垃圾引起的系统停顿时间几乎可以忽略不计，web项目一般使用CMS收集老年代\n\n```bash\n#使用CMS收集器，CMS是ConcMarkSweep的缩写\n-XX:+UseConcMarkSweepGC\n```\n&nbsp;\n缺点：①对CPU资源非常敏感、在多核下才有优势，②并发清除阶段不能清除用户线程新产生的垃圾，③标记清除会产生内存碎片。\n\n&nbsp;\n\n#### G1收集器\nG1将整个堆划分为多个大小相等的独立区域（Region），使用标记整理算法。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601111757373.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n- 初始标记（Initial Marking) ：标记作为GC Root的对象\n- 并发标记（Concurrent Marking）：根据可达性分析算法找出各个Region所有的引用链\n- 最终标记（Final Marking) ：修正并发标记期间因用户程序导致的标记变动\n- 筛选回收（Live Data Counting and Evacuation)：回收各个Regin中Remembered Set 之外的部分\n&nbsp;\n\nG1的特点\n- 空间整合，不会产生内存碎片\n- G1、CMS都关注于缩短系统停顿时间，但G1的系统停顿是可预测的\n- 面向整个堆进行垃圾回收，新生代、老年代不再物理隔离\n- 回收价值高。G1 跟踪各个 Region 里面垃圾的回收价值，记录回收所获得的空间、所花费的时间，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。这也是 Garbage- Firsti 名称的由来、以及可预测的原因，这种方式保证了 G1 在有限时间内获取尽可能高的回收价值。\n&nbsp;\n\nG1是最优的，但G1出来不久稳定性不如CMS，目前web项目一般使用CMS收集老年代+ParNew收集新生代。\n\n&nbsp;\n\n#### 垃圾收集器总结\n名称 | 收集年代 | 使用的垃圾回收算法 | gc线程 | 关注点 | 地位\n-- | -- | -- | -- | -- | --\nSerial收集器 | 新生代 | 复制算法 | 单线程 |  | client模式下默认的新生代收集器\nParNew收集器 | 新生代 | 复制算法 | 多线程 |  | 新生代主流使用的收集器\nParallel Scavenge收集器 | 新生代 | 复制算法 | 多线程 | 关注吞吐量 | server模式下默认的新生代收集器\nSerial Old收集器 | 老年代 | 标记整理算法 | 单线程 |  | client模式下默认的老年代收集器\nParallel Old收集器 | 老年代 | 标记整理算法 | 多线程 | 关注吞吐量 | server模式下默认的老年代收集器\nCMS收集器 | 老年代 | 标记清除算法 | 单线程、多线程混合 | 关注缩短系统停顿时间 | 老年代主流使用的收集器\nG1收集器 | 所有年代 | 标记整理算法 | 单线程、多线程混合 | 关注缩短系统停顿时间、高价值回收 | 优秀，但出来不久，稳定性不如CMS\n\n新生代对象存活率低，都是使用复制算法；老年代对象存活率高，一般使用标记整理算法。\n\nCMS使用标记清除算法，关注缩短系统停顿时间。', 28, 'JVM', 'JVM垃圾回收机制', 1, 0, 0, 0, '2020-06-27 19:31:55', '2020-06-27 19:31:55');
INSERT INTO `tb_blog` VALUES (14, 'ZK基础知识', '', 'http://127.0.0.1:9501/admin/dist/img/rand/12.jpg', '\n\n### zk的数据模型\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020053019015439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n树结构，/是根节点，节点叫做znode，一个znode对应一个文件目录。\n&nbsp;\n\n**有四种类型的znode**\n- PERSISTENT  持久，znode创建后一直保留\n- PERSISTENT_SEQUENTIAL  持久、顺序编号\n- EPHEMERAL  临时，创建znode的zk client断开与zk server的连接后，zk server会自动删除该znode\n- EPHEMERAL_SEQUENTIAL   临时、顺序编号\n\n临时节点常用于实现分布式锁。\n\n&nbsp;\n\n### zk server的集群模式\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200530204421741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n&nbsp;\n\n**zk server有3种角色**\n- leader   &emsp;负责处理zk client的写（、读）请求，一个zk集群只有一个leader\n- follower  &emsp;同步leader的数据，负责处理zk client的读请求，并参与leader的选举\n- observer  &emsp;负责处理zk client的读请求，但不参与leader的选举\n\nzk集群是读写分离的模式，leader负责写（也可以处理读），follower负责读。\n\n&nbsp;\n\n**有follower就够了，为什么还要使用observer？**\n\n1、提高并发负载\n\nobserver可以协助 follower 处理更多的读请求，提高读请求的吞吐量\n&nbsp;\n\n2、减少选举的时间花销\n\neg. follower5个、observer6个，选举leader只需要等待3台机器同意；如果11个全是follower，需要等待6个同意，大大增加了选举的时间花销。\n&nbsp;\n\n3、提高集群可用性\n\ndown掉一半集群不可用，指的是followerdown掉一半，observer不参与数量统计，就算observer全部宕掉，也没关系。\n\neg. follower5个、observer8个，down掉所有observer、2个follower总共10个，集群仍然可用；如果13个全是follower，宕掉7个集群就不可用，显然使用observer可用性更高。\n\n&nbsp;\n\n**zk server集群至少需要3个zk server，为什么官方推荐参与集群的zk server数量为奇数？**\n\n因为单数、双数的容灾能力一样，少用一台机器还可以节约成本。\n\neg. zk server数量为5，down掉3个集群就不可用；数量为6，还是down3个集群就不可用。容灾能力（可用性）一样，少用1台机器还节约了成本。\n\n&nbsp;\n\n### zk的工作原理\nzk的核心机制是原子广播，这个机制保证了zk server之间的数据同步。\n&nbsp;\n\n实现原子广播的协议是Zab协议，Zab协议有3种模式\n- 恢复模式。leader故障后自动进入恢复模式，将集群恢复到正常工作状态。先从follower中选出一个新leader，其它follower从新leader处同步数据，大多数follower完成同步恢复模式就结束了。\n- 同步模式。follower从leader处同步数据。同步模式也是恢复模式的一部分。\n- 广播模式。leader处理写请求时，广播通知follower发起投票，半数以上的follower同意后，leader执行写请求（修改自身的znode），执行后将修改、更新广播给follower、observer，完成数据同步。\n\n&nbsp;\n\n### leader的选举机制\n**zk server在集群中的4种状态**\n- LOOKING：leader宕掉了，尚未选出新leader\n- LEADING：当前zk server成为leader\n- FOLLOWING：当前zk server是follower，同步leader的数据\n- OBSERVING：当前zk server是observer，同步leader的数据\n \n&nbsp;\n\n**相关概念**\n1、myid\n\n唯一标识集群中的一个zk server\n&nbsp;\n\n2、zxid\nzxid其实是一个ReentranReadWriteLock，为保证数据一致性，一个节点同一时刻只执行一个读写操作，自然要加锁。follower、observer只是对外不处理写请求，同步leader数据时依然要同步写操作。\n\nzxid的前32位表示epoch（纪元、时代），一个leader对应一个epoch（时代），换了新leader，epoch会自动使用新值。\n\nzxid的后32位表示xid，每一个写操作都是一个事务，xid即事务id。\n\nmyid标识的是zkServer节点，zxid标识的是数据版本。\n &nbsp;\n\n3、Logicalclock  逻辑时钟\n逻辑时钟是选举时的一个概念，其值就是zxid中epoch的值，标识一个时代。选举出新的leader，新leader的统治时代就此诞生。\n\n&nbsp;\n\n**leader的选举时机**\n- 集群启动还没有leader时\n- leader宕机时\n \n&nbsp;\n\n**leader的选举机制、过程**\n\n- 集群没有leader，所有zk server都是LOOKING状态\n- 所有follower都参与投票，投的都是自己，写上自己的myid、zxid，广播出去\n- 比较zxid，先选epoch大的（纪元新的）；如果有相同的从里面选xid大的（同步数据多的）。这2项都是为了保证新leader的数据更齐全。如果还有相同的，选myid大的。\n- 选出新leader后，其它zk server从新leader处同步数据，leader状态变为LEADING，follower转态变为FOLLOWING，observer状态变为OBSERVING。\n\n&nbsp;\n\n### zk server如何处理zk client的请求？\n读请求：所有的zk server都可以处理读请求，leader收到读请求也会处理；\n写请求：由leader处理，follower、observer收到写请求时转交给leader处理。\n&nbsp;\n\nleader使用paxos算法来处理写请求\n- leader将写请求都放到一个队列中，并给每个写请求分配唯一的编号，编号从小到大依次递增，按照先进先出的顺序处理\n\n- 执行某个写请求时，leader先向follower发起投票，是否要执行这个写请求，如果超过半数的follower同意，leader就会执行这个写请求。同一时刻，leader只执行一个写请求，以保证数据的一致性\n\n- follower、observer同步数据（写操作）时，会与前面已同步的写请求的编号对比，如果编号小于之前已同步的写请求的编号，说明自己数据同步出了问题，数据不一致了，立刻停止对外服务，从leader同步全量数据。\n&nbsp;\n\n准确来说不是先投票再执行。执行流程：\n- leader直接执行写请求，执行完后广播通知follower、observer同步这个写操作，follower、observer从leader处同步这个写操作。整个流程作为一个事务来处理。\n- 如果半数以上follower、observer完成同步（完成写操作），就提交事务（投票通过）；如果在指定时间内完成同步的zk server数量没达到一半，就回滚这个写操作（投票失败）。\n\n其实并不算投票，只是统计指定时间内完成该写操作同步的zk server数量。\n\n&nbsp;\n\n### zk的特点\n- 顺序一致性：zk server使用paxos算法来处理请求，将请求放在队列中，先进先出，请求的执行顺序与发送顺序一致。可用此特点实现队列\n- 数据更新原子性：一次写操作即一个事务，要么成功（都应用、同步到所有节点），要么失败（所有节点都不使用这次数据更新）\n- 单一视图: zk client无论连接到哪个zk server，读到的数据都是相同的\n- 实时性: zk client读取到的是zk server上最新的数据\n- 高性能：zk server将全量数量存储在内存中，性能极高，尤其是处理读请求的时候。处理写请求（更新znode）时，要把更新从内存同步到文件，同步到follower、observer，性能稍低\n\n&nbsp;\n\n### zk的心跳机制\nzk通过心跳机制维护各个zk client的状态。\n\nzk cli每隔一定时间（默认2000ms）发送一个心跳包给zk server，如果zk server连续多少次（默认10次）没有收到某个zk cli的心跳包，就认为该zk cli挂了，自动销毁对应的session、删除本次会话中创建的临时节点。\n\n&nbsp;\n\n### zk的watcher机制\n也叫作观察/通知机制，zk client可以watch某个znode，指定的znode发生改变时，zk server会通知watch了此znode的zk client。\n\n这其实是一种特殊的发布/订阅，zk client订阅znode的改变事件，指定的znode发生改变时zk server发布消息，订阅了该znode改变事件的zk client会收到消息。\n\nwatcher是观察者模式的体现，观察到某种现象发生时自动做一些事情。\n&nbsp;\n\n有2种watcher\n```bash\n# get、stat这2种方式设置的watcher，都只监听节点本身的数据变化，不监听子孙节点\nget  -w /mall\nstat -w /mall\n\n\n# ls方式设置的watcher只监听子节点的数量变化，不监听节点本身的数据变化，也不监听孙节点\nls -w /mall\n```\nwatcher是一次性的，触发1次后就销毁，如果要继续监听，需要重新设置watcher。\n\n&nbsp;\n\n### acl 权限控制\n可以给znode设置用户权限，限制用户对znode可以进行的操作，提高数据安全性。\n&nbsp;\n\n**znode的acl权限**\n- c：create，可创建子节点\n- d：delete，可删除子节点\n- r：read，可读取节点数据\n- w：write，可写入|更新节点数据\n- a：admin，可管理此节点，配置acl权限\n\n&nbsp;\n\n**acl权限操作**\n```bash\n# 查看指定节点的acl权限设置，默认所有用户的权限都是cdrwa（全部权限）\ngetAcl /mall\n\n# 统一设置所有用户的权限，world:anyone:权限\nsetAcl world:anyone:cdrw\n\n\n# 设置某个用户的权限\n\n# auth:用户名:密码:权限\nauth:chy:abcd:cdrw\n\n# 或者 digest:用户名:BASE64(SHA1(密码)):权限\ndigest:chy:BASE64(SHA1(abcd)):cdrw\n\n# auth、digest设置的密码都是以密文方式存储在zk server上，但验证密码时auth是输入明文、digest是输入SHA1加密后的密文。\n# auth更简单，digest更安全、但也更麻烦\n\n\n# 根据ip设置权限\nip:192.168.1.1:cdrw\n\n# 给znode设置用户权限后，操作该znode时需要验证用户名、密码\naddauth digest chy:abcd\n```\n&nbsp;\n\n**设置超级用户**\n超级用户具有所有的acl权限，可以操作所有的znode。\n&nbsp;\n先在IDEA中获取密文\n```java\n//用户名:密码，此处设置的用户名、密码都是super\nString str = DigestAuthenticationProvider.generateDigest(\"super:super\");\nSystem.out.println(str);\n```\n&nbsp;\n编辑bin目录下的zkServer.sh\n```bash\nvim zkServer.sh\n\n# 找到以下代码\nnohup \"$JAVA\" $ZOO_DATADIR_AUTOCREATE \"-Dzookeeper.log.dir=${ZOO_LOG_DIR}\" \\\n    \"-Dzookeeper.log.file=${ZOO_LOG_FILE}\" \"-Dzookeeper.root.logger=${ZOO_LOG4J_PROP}\" \\\n\n# 在第二行末尾的\\之前加上以下代码，superDigest=后面是IDEA输出的密文\n\"-Dzookeeper.DigestAuthenticationProvider.superDigest=super:gG7s8t3oDEtIqF6DM9LlI/R+9Ss=\"\n```\n超级用户可以管理所有的znode，但如果在设置超级用户之前，就已创建了某些znode、并手动给这些znode设置了acl权限，则超级用户对这些之前创建的znode没有管理权限。\n\n\n\n\n\n\n \n \n\n ', 29, 'ZK', 'zk', 1, 0, 0, 0, '2020-06-27 19:33:28', '2020-06-27 19:33:28');
INSERT INTO `tb_blog` VALUES (15, 'Redis持久化方案', '', 'http://127.0.0.1:9501/admin/dist/img/rand/7.jpg', '\n\n关闭redis server时，会将内存中的数据持久化到硬盘；启动redis server时，会从硬盘加载数据到内存；redis server运行时，每隔一段时间会自动同步内初中的数据到硬盘。\n\n有3种持久化方案：RDB，AOF，RDB-AOF搭配使用。\n&nbsp;\n\n### RDB（默认）\nrdb是redis默认使用的持久化方案，隔一段时间同步一次，使用快照保存内存中的全量数据。\n&nbsp;\n\n#### 相关配置\n在redis.conf中搜索rdb即可看到rdb相关配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200526232213587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\nRDB默认设置了3种策略，分别对应redis服务器key的更新（增删改）频率\n- 如果900s（即15min）内，对键值对的修改个数达到1，就同步数据到硬盘。对应修改频率低的情况。\n- 如果300s（即5min）内，对键值对的修改个数达到10，就同步数据到硬盘。对应修改频率一般的情况。\n- 如果60s（即1min）内，对键值对的修改个数达到10000，就同步数据到硬盘。对应修改很频繁的情况。\n\n如果要禁用rdb，在下面加一行即可\n```bash\nsave \"\"\n```\n&nbsp;\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200604121030972.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n默认持久化到硬盘出错时会停止接受写请求，防止新写入内存中的数据因为故障而丢失。\n\n默认会压缩.rdb文件的体积，压缩可以减小硬盘占用，但压缩时会加大redis的cpu开销，redis是cpu密集型服务器，开启压缩会消耗更多的cpu，与硬盘相比cpu更值钱，建议改为no。\n\n&nbsp;\n\n#### rdb的持久化过程\n达到同步要求后，启动一个子进程，将内存中的全量数据写到一个临时文件中，完成后用临时文件替换原来的.rdb文件。\n\n&nbsp;\n\n### AOF\naof是把执行过的写指令记录到一个.aof文件中（相当于写指令的日志），启动redis server时，把.aof中的写指令重新执行一遍，还原数据。\n&nbsp;\n\n#### 相关配置\nredis.conf中搜索append即可找到aof相关配置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020052623320151.png)\n默认没有开启aof，如果要使用aof，将no改为yes即可\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200526233857117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n向.aof文件追加写指令（同步）有3种策略\n- always  每执行完一条写指令，就往.aof文件中追加该指令，开销大、拉低服务器性能，但数据最安全，宕机最多丢失1个写指令\n- no：把写指令放到缓冲区里，缓冲区满了才会写到.aof文件中，资源开销最小，但数据不安全，宕机时缓冲区里的写指令全部丢失\n- everysec：上面2种的折中，每秒往.aof文件中追加一次，一次性写入这一秒内执行的所有写指令，宕机丢失上一秒内的写指令。默认使用everysec，一般也是使用这个。\n&nbsp;\n\n#### aof持久化的执行过程\n达到同步要求后，启动一个子进程，把新增的写指令添加到.aof文件中。\n\n&nbsp;\n\n#### aof重写\n.aof文件中的写指令越来越多，文件越来越大，还原数据越来越慢。当.aof文件体积达到指定值时自动启动一个子进程重写.aof文件，减少.aof中的写指令数量，减小.aof文件的体积。\n\n```bash\nhmset user name \"chy\" age 20\nhset user name \"chy01\"\nhset user age 22\n\n#aof重写后，以上3条写指令会重写为一条\nhmset user name \"chy01\" age 22   #直接写最终结果\n```\n&nbsp;\n\naof的重写策略\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527000437556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\nredis会记录重写后.aof的文件大小，如果redis server启动后还没有重写过.aof文件，则默认为redis server启动时.aof的文件体积。\n\n- 如果.aof文件的体积，比上一次重写后增加了百分之多少（默认100，即翻1倍），就自动重写aof文件。设置为0即禁用aof重写。\n- 如果aof文件的体积，比上一次重写后增加了多少（默认64mb），就自动重写aof文件\n\n&nbsp;\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020052700163539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n重写aof文件时是否不同步写指令到.aof中，默认要同步\n\n&nbsp;\n\n### RDB、AOF的对比\n- rdb是全量同步，IO压力大，影响性能；aof只添加新增的写指令，资源占用少、时间开销小\n- redis故障时rdb数据丢失量往往比aof大，aof数据安全性、完整性更高\n- rdb文件体积小，aof文件体积大\n- rdb数据还原快，redis启动快；aof数据还原慢，redis启动慢\n\n&nbsp;\n\n### RDB-AOF混合持久化（推荐）\n第一次用rdb同步全量数据，以后使用aof同步增量，记录新增的写指令，确保redis故障时数据丢失少。redis启动时主要数据从rdb加载，还原速度快。\n\n&nbsp;\n\n### 手动同步数据到硬盘\n```bash\nsave  #在主线程中进行同步，会阻塞主线程，同步完成主线程才能处理读写请求\n\nbgsave  #后台启动一个子进程进行同步\n```\n\n\n \n', 30, 'Redis', 'redis持久化', 1, 0, 0, 0, '2020-06-27 19:34:53', '2020-06-27 19:34:53');
INSERT INTO `tb_blog` VALUES (16, 'Redis集群、哨兵', '', 'http://127.0.0.1:9501/admin/dist/img/rand/5.jpg', '@[TOC](目录)\n&nbsp;\n\n### redis集群简介\n单机版redis server，redis server容量受单机内存限制，往往需要redis server集群来扩容，提升redis数据库的容量。\n\nredis 5.0之前通过执行redis-trib.rb创建redis集群，redis-trib.rb是ruby语言写的脚本，需要配置ruby环境，还需要安装redis.gem来管理集群。redis 5.0开始用redis-cli代替redis-trib.rb，虽然redis-trib.rb现在还能用（向下兼容），但后续会被取消掉，建议使用redis-cli来创建集群。\n\n此处以redis 5.x为例创建redis集群。\n\n```bash\n# 查看redis server版本\n./redis-server -v\n./redis-server --version\n```\n\n&nbsp;\n\n### 搭建redis集群\n**1、redis集群至少要3个master，且每个master至少要有一个slave，所以最少要6个节点**\n\n如果节点数量不满足要求，后续会报错\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527095426608.png)\n&nbsp;\n \n**2、编辑所有集群节点的redis.conf，允许集群**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527094551238.png)\n参加集群的所有节点都不能是slave，如果配置了replicaof，将其注释掉。\n哪些节点作为master、哪些节点作为slave，由集群自动分配，不能手动设置。\n\n\n&nbsp;\n\n**3、参与集群的节点，数据库必须是空的，如果有.rdb、.aof等数据库文件，需先删除**\n\n如果集群搭建失败，重试时需要先删除之前生成的数据库文件（.rdb、.aof）。如果数据库不为空，后续会报错\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527094505343.png)\n&nbsp;\n\n**4、先启动参与集群的每个redis server，再使用某个redis-cli创建集群**\n```bash\n./redis-cli --cluster create 192.168.1.1:6379 192.168.1.2:6379 192.168.1.3:6379 192.168.1.4:6379 192.168.1.5:6379 192.168.1.6:6379 --cluster-replicas 1\n```\n指定参加集群的节点（ip、port），参数cluster-replicas指定每个master分配几个slave。自动分配时，一般是前面的节点都作为master，后面的都作为slave。\n&nbsp;\n\n会给出集群配置方案。（图是以前我在本地模拟时截的，所以ip都是127.0.0.1，只修改了端口。）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527100835938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\nM是master，S是slave，slot（槽点）是用来执行写指令的，只分配给master，各个master的槽点数差不多。slave只是作为备份，不执行写指令，不分配槽点。\n\n输入yes按方案执行\n\n&nbsp;\n\n**5、连接到集群中的某个节点即可连接到整个redis集群，查看集群信息**\n```bash\n# 连接到集群时，不管是连接到master还是slave，都要加-c，c即cluster\nredis1/bin/redis-cli -h 192.168.1.1 -p 6379 -c  \n\n# 查看集群信息\ncluster info\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527101919165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n集群状态、槽点数、节点数都可以看到，其中集群大小cluster_size只算master。\n\n&nbsp;\n\n```bash\n# 查看当前连接到的节点的主从信息\ninfo replication\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527102309355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n可以看到当前节点的角色，如果是master会显示其从节点的信息，如果是slave会显示如果其master的信息。此外还能看到数据同步的偏移量。\n&nbsp;\n\n设置值、取值\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527102830633.png)\n先根据key的哈希值确定槽点位置，自动转到该槽点所在的节点，然后在该槽点处设置值、取值。\n\n&nbsp;\n\n### redis集群原理\nredis集群是把数据分散存储在多个master上，这些master共同组成一个完整的redis数据库，每个master上只存储部分key，也叫作分片。每个master都可以处理请求，slave只用于所属master的数据备份，不处理请求。\n&nbsp;\n\n#### 哨兵（Sentinel）机制\n哨兵是redis server附带的程序，每个redis server（master、slave）都自带得有，默认未配置哨兵。redis server默认使用6379，哨兵默认使用26379。\n\n创建redis集群时，会自动给每个节点配置哨兵，用于监控集群中各个节点（master+slave）的状态。每个节点（master+slave）上都有一个节点信息文件记录集群各节点的信息\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527103125507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n包括各个节点的ip、port，角色（master、slave），是集群中的第几个节点，和当前节点之间是否能ping通（是否connected）。如果是master，还包括槽点区间。\n\n&nbsp;\n\n##### 设置值、取值流程\n设置值、取值的时候，先根据key的hash值确定槽点位置，再根据节点信息文件确定该槽点所在节点（ip、port），转交给该节点操作。\n\n&nbsp;\n\nredis.conf\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527114155250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n第一个配置是节点信息文件的保存路径，默认保存路径是数据存储目录（.aof、.rdb所在目录）下的nodes.conf文件。\n\n创建集群时会往每个节点的nodes.conf中写入集群初始配置，集群创建后，每个节点的哨兵每秒都会ping一下其它节点，确定其它节点的状态，来维护|更新节点信息文件。\n\n&nbsp;\n\n\n第二个配置指定超时时间，默认15000ms，即15s。如果哨兵在15s内都没有ping通某个节点，就主观认为该节点down掉了，将该节点的状态标识为sdown，s即subjectively 主观。\n\n如果超过一半的master都将某个master的状态标识为sdown，就认为客观上该master节点确实down掉了，将该master节点的状态标识为odown，o即objectively ，客观。哨兵会自动将从该master的所有slave中选一个新的master。注意是哨兵确定新的master，不是由其它master确定。\n\n&nbsp;\n\n#### 故障迁移 failover\n故障迁移是指：master故障，从附属slave中选出新master，其它附属slave从新master同步数据的过程。具体过程如下\n\n- try-failover   &emsp;master的状态被标识odown，集群尝试进行故障转移\n- elected-leader   &emsp;从该master的附属slave中选出新master\n- selected-slave   &emsp;已选出新的master\n- send-slaveof-noone   &emsp;向新master发送slaveof  no  one命令，摆脱slave地位\n- wait-promotion   &emsp;等待新master完成配置更新，晋升为master。配置更新有2个方面：一是去掉replicaof配置摆脱slave角色，二是继承原master的槽点、得到写权限（slave默认只读）\n- promoted   &emsp;晋升完成\n- 其它附属slave从新master同步全量数据\n\n故障迁移期间，整个redis集群不对外提供服务。redis集群和zk集群很相似，数据一致性强，但可用性得不到保证。\n\n&nbsp;\n\n#### 晋升机制\nredis.conf\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527124736291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n优先级有3个值：10，25，100，默认100。\n\n选举新master时自动选择优先级大的，如果优先级相同，则看偏移量，偏移量小的数据新，自动选择偏移量小的。\n\n&nbsp;\n\n#### 集群不可用\n以下2种情况都会使redis集群不可用（集群状态为fail）\n- 某个master节点及其所有slave节点都down掉\n- master节点短时间内down掉一半以上，不管有没有代替的slave，整个集群直接不可用\n\n&nbsp;\n\n### 主从同步\n创建redis集群时会自动设置哨兵、主从关系\n &nbsp;\n \n#### 主从同步的作用\n- 数据冗余（备份）\n- 提高可用性：master故障，可将某个slave作为新的master\n\n\n至于读写分离，用master处理写请求（、读请求），slave处理读请求，这对redis来说没必要。\n\n读写分离主要有2个作用：①减轻master压力，提高整体负载，②提高性能。\n\n关系数据库读写数据要进行文件IO，耗时、性能差，需要读写分离提高性能，redis本身是内存数据库，性能极高，不需要读写分离来提高性能；关系数据库集群通常是一主多从，需要从库分担读请求的压力，redis集群本身就有多个master，通过多个master来分担读写压力、存储压力，不需要slave来分担。\n\n所以redis集群一般不做读写分离，没必要，slave只作数据备份，读写请求都由master处理。\n\n&nbsp;\n\n#### redis的同步机制\n全量同步\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200604141357612.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n&nbsp;\n\n增量同步\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060414160645.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoeV8xODg4MzcwMTE2MQ==,size_16,color_FFFFFF,t_70)\n\n\n\n\n\n\n', 30, 'Redis', 'redis集群', 1, 0, 0, 0, '2020-06-27 19:35:40', '2020-06-27 19:35:40');
INSERT INTO `tb_blog` VALUES (17, 'MyBatis实用总结', '', 'http://127.0.0.1:9501/admin/dist/img/rand/33.jpg', '@[TOC](目录)\n&nbsp;\n\n### xml映射文件\n#### 与mapper接口的对应关系\n- namespace和接口名一致（xml文件名不需要和接口名一致）\n- id和接口中的方法名一致\n- 参数类型、返回值类型与接口方法中的一致\n\n&nbsp;\n\n#### parameterType、resultType\n- 如果是基本类型，一律使用包装类型\n- 别名规则：类名全小写\n- 如果返会的结果集中有多条记录（List），resultType不能写成list，和返回单条记录一样都是写元素类型，eg. List\\<User> => user ，如果返回了多条记录，会自动映射为指定类型的List。\n\n&nbsp;\n\n#### 参数问题\n**如果使用了parameterType，只能传入一个参数，如果要传入多个参数，可以放到list、map中传入**\n```xml\n<!-- 传入list -->\n<select id=\"xxx\" parameterType=\"list\" resultType=\"xxx\">\n	<!-- 默认的列表名是list，通过下标取值 -->\n    SELECT * FROM tb_user WHERE name=#{list[2]}\n</select>\n\n\n<!-- 传入对象 -->\n<select id=\"xxx\" parameterType=\"user\" resultType=\"xxx\">\n	<!-- 通过成员变量名直接取，会自动调用对应的getter方法 -->\n    SELECT * FROM tb_user WHERE name=#{name}\n</select>\n\n<!-- 传入map -->\n<select id=\"xxx\" parameterType=\"map\" resultType=\"xxx\">\n	<!-- 通过key直接取 -->\n    SELECT * FROM tb_user WHERE name=#{name}\n</select>\n```\n&nbsp;\n\n**不使用parameterType，可直接传入多个参数**\n```java\npublic interface UserMapper{\n    User findUser(Integer id, String name);\n}\n```\n\n```xml\n<!-- 不要parameterType -->\n<select id=\"findUser\" resultType=\"user\">\n    SELECT * FROM tb_user WHERE id=#{id} and name=#{name}\n</select>\n```\n&nbsp;\n\n**@Param可解决mapper接口、xml映射文件参数名不同的问题**\n```java\npublic interface UserMapper{\n    // 通过@Param绑定xml中的name变量\n    User findUser(Integer id, @Param(\"name\") String username);\n}\n```\n\n```xml\n<select id=\"findUser\" resultType=\"user\">\n    SELECT * FROM tb_user WHERE id=#{id} and name=#{name}\n</select>\n```\n\n&nbsp;\n\n#### #{ }、${ }的区别\n#{ }用于取值，\\${ }除了有#{ }的功能，还可以拼接字符串，但使用\\${ }拼接字符串有sql注入的风险。\n\n以模糊查询为例\n```xml\n<select id=\"xxx\" parameterType=\"string\" resultType=\"user\">\n	SELECT * FROM tb_user WHERE name LIKE \'%${name}%\'\n</select>\n\n\n<select id=\"xxx\" parameterType=\"string\" resultType=\"user\">\n	<!-- 使用sql的concat()函数拼接字符串，使用#{}取值 -->\n	SELECT * FROM tb_user WHERE name LIKE concat(\'%\',#{name},\'%\')\n</select>\n```\n\n&nbsp;\n\n#### resultMap的使用\n\\<resultMap>  用于自定义结果集映射\n\n```xml\n<!-- resultType不能和resultMap同时使用，fetchSize指定返回的记录数，未指定时默认返回所有满足要求的记录 -->\n<select id=\"\" parameterType=\"\" resultMap=\"resultMap\" resultType=\"user\" fetchSize=\"10\">\n\n</select>\n\n\n<!-- type指定po -->\n<resultMap id=\"userMap\" type=\"user\">\n    <!-- 默认映射规则是同名映射，我们只需指定名称不一致的字段，主键字段用id指定，普通字段用result指定 -->\n    <id property=\"id\" column=\"user_id\"/>\n    <result property=\"username\" column=\"user_name\"/>\n</resultMap>\n\n<!-- resultMap属性指定要使用的<resultMap> -->\n<select id=\"\" parameterType=\"\" resultMap=\"userMap\">\n\n</select>\n```\n此外，\\<resultMap>还有2个常用子元素\\<association>、\\<collection>，用于关联映射。\n\n&nbsp;\n\n### 关联映射\n**关系数据库中，多表之间有三种关联关系**\n- 一对一：一张身份证对应一个人 <=> 一个人也只对应一张身份证\n- 一对多：一个用户可以有多个订单 <=> 这多个订单都属于同一个用户\n- 多对多：一个订单可以包含多种商品 <=> 一种商品可以属于多个订单\n\n&nbsp;\n\n**设计数据库时如何处理三种关联关系？**\n- 一对一：在一方引入另一方的主键作为外键\n- 一对多：在多的一方，引入一的一方的主键作为外键\n- 多对多：新建一张中间表，引入2张表的主键作为外键，可以使用这2个外键作为中间表的联合主键，也可以新建id字段作为中间表的主键\n\n&nbsp;\n\n**java如何处理、描述三种关联关系？**\n```java\n// 一对一\nclass A{\n    B b;\n}\n\nclass B{\n    A a;\n}\n```\n\n```java\n// 一对多，A是一，B是多\nclass A{\n    List<B> b;\n}\n\nclass B{\n    A a;\n}\n```\n\n```java\n// 多对多\nclass A{\n    List<B> b;\n}\n\nclass B{\n    List<A> a;\n}\n```\n\n&nbsp;\n\n**如果多表查询返回的结果集中包含另一方的字段，如何映射？**\n```xml\n<select id=\"findStudentById\" parameterType=\"integer\" resultMap=\"studentWithScoreMap\">\n    <!-- 一对一、一对多都是根据关联外键来查2张表，多对多是根据中间表来查2张表、是3表联查 -->\n    SELECT st.*,sc.* FROM tb_student st ,tb_score sc  WHERE st.id=#{id} AND st.id=sc.student_id\n </select>\n\n\n<resultMap id=\"studentWithScoreMap\" type=\"student\">\n    <!-- 如果其它字段名称不一致，手动映射 -->\n    <id property=\"\" column=\"\"/>\n    <result property=\"\" column=\"\"/>\n\n    <!--  一对一用association，javaType指定成员变量类型 -->\n    <association property=\"score\" javaType=\"score\" />\n\n    <!-- 如果名称不匹配，手动指定映射 -->\n    <association property=\"score\" javaType=\"score\">\n        <id property=\"\" column=\"\" />\n        <result property=\"\" column=\"\"/>\n    </association>\n\n\n    <!-- 一对多、多对多用collection。注意是ofType，指定List元素类型 -->\n    <collection property=\"\" ofType=\"\" />\n\n    <!-- 如果名称不匹配，手动指定映射 -->\n    <collection property=\"\" ofType=\"\">\n        <id property=\"\" column=\"\" />\n        <result property=\"\" column=\"\"/>\n    </collection>\n    \n</resultMap>\n```\n\n&nbsp;\n\n### 动态sql\n动态sql是mybatis的强大特性之一，可以实现sql语句的动态组装。\n&nbsp;\n\n**\\<where>、\\<if>**\nwhere：如果有内容就添加关键字WHERE\nif：如果条件为true就添加内容\n常用于多条件查询，一个输入框指定一个条件，有的输入框可能没填\n```xml\n<select id=\"findUser\" resultType=\"user\">\n	SELECT * FROM tb_user\n	<where>\n	   <if test=\"name!=null and name!=\'\'\">\n	       name=#{name}\n	   </if>\n	   <if test=\"gender!=null and gender!=\'\'\">\n	       AND tel=#{gender}\n	   </if>\n	</where>\n</select>\n```\n\n&nbsp;\n\n**\\<choose>、\\<when>、\\<otherwise>**\n相当于switch语句，\\<when>相当于case，\\<otherwise>相当于default，条件为true就加上对应的sql语句\n```xml\n<select id=\"findStudent\" resultType=\"student\">\n	SELECT * FROM tb_student WHERE dep=#{dep}\n	<choose>\n	    <when test=\"englishLevel==\'cet4\'\">\n	        AND english_level=\'cet4\'\n	    </when>\n	    <when test=\"englishLevel==\'cet6\'\">\n	        AND english_level=\'cet6\'\n	    </when>\n	    <otherwise>\n	        AND english_level<>\'cet4\' AND english_level<>\'cet6\'\n	    </otherwise>\n	</choose>\n</select>\n```\n\n&nbsp;\n\n**\\<set>**\n传入pojo类型，更新多个字段，但对象的部分字段可能没有值，不能用jvm赋的初值null、0去覆盖表中原来的值，需要先判断。\n\n\\<set>用于更新操作，可更新一个对象、也可批量更新（list）。如果有内容，会自动加关键字SET，并自动去除内容中多余的逗号。\n\n```xml\n<select id=\"updateUser\" parameterType=\"user\">\n	UPDATE tb_user\n	<set>\n	    <if test=\"name!=null and name!=\'\'\">\n	    	<!-- 如果后面的内容都为false，会自动去掉这个逗号 -->\n	        name=#{name},\n	    </if>\n	    <if test=\"age!=0\">\n	        age=#{age},\n	    </if>\n	    <if test=\"tel!=null and tel!=\'\'\">\n	        tel=#{tel},\n	    </if>\n	</set>\n	where id=#{id}\n</select>\n```\nupdate语句至少要有一个字段更新，不然会报：语法错误。\n\n&nbsp;\n\n**\\<foreach>**\n\\<foreach>用于迭代集合，常配合sql关键字in使用，批量操作记录。\n\n- collection   &emsp;要迭代的集合的数据类型，List=>list，Map=>key的数据类型\n- index    &emsp;当前迭代次数，从0开始\n- item    &emsp;当前迭代元素，map是key\n- open    &emsp;拼接这整段字符串时以什么开头\n- close   &emsp;拼接这整段字符串时以什么结尾\n- separator    &emsp;迭代添加的元素之间用什么分隔\n\ncollection必需，其余均可选。\n\n```xml\n<select id=\"findStudent\" parameterType=\"list\" resultType=\"student\">\n	SELECT * FROM tb_student WHERE dep IN\n	<foreach collection=\"list\" index=\"index\" item=\"item\" open=\"(\" separator=\",\" close=\")\">\n	   #{item}\n	</foreach>\n</select>\n```\n\n&nbsp;\n\n**\\<bind>**\n${ }可拼接字符串，但有sql注入的风险。\n\n使用数据库自带的方式拼接字符串没有sql注入的风险，mysql可以使用concat()拼接字符串，oracle可以使用 || 拼接字符串，但都只能针对特定的数据库使用，不利于项目移植。\n\n\\<bind>可拼接字符串，没有sql注入的风险，所有数据库都可用。\n\n```xml\n<!-- 模糊查询 -->\n<select id=\"queryUser\" parameterType=\"string\" resultType=\"user\">\n	<bind name=\"pattern_name\" value=\"\'%\'+name+\'%\'\"/>\n	SELECT * FROM user_tb WHERE name LIKE #{pattern_name}\n</select>\n```\n\n&nbsp;\n\n**说明**\n\n1、在元素属性中访问参数，不加#{ }、\\${ }，直接访问；在标签体中访问参数，要加#{ }、\\${ }\n&nbsp;\n2、test属性\n- 相等判断：==，!=\n- 逻辑与：只能用and，不能用&&\n- 逻辑或：or、||均可\n\n&nbsp;\n\n### BindingException: Invalid bound statement (not found)\n检查以下方面\n\n1、xml映射文件的namespace和接口名是否一致，namespace要是接口名的全路径，id和接口中的函数名是否一致，参数类型、返回值类型是否一致\n\n2、application.properties中mybatis的配置是否正确\n\n3、xml映射文件是否忘写了后缀.xml\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200528131305203.PNG)\n第二个才是对的\n\n\n\n', 31, 'MyBatis', 'mybatis', 1, 0, 0, 0, '2020-06-27 19:37:13', '2020-06-27 19:37:13');
INSERT INTO `tb_blog` VALUES (18, 'RabbitMQ消息的可靠性投递', '', 'http://127.0.0.1:9501/admin/dist/img/rand/35.jpg', '### 可靠性投递\n1、保障消息能够成功发出\n\n2、保障rabbitmq（broker）能够成功接收。接收指的是：broker接收到生产者发送的消息，放到exchange中，分发给对应的queue，交付给对应的消费者。\n\n3、发送端要收到broker的确认应答，确认broker已收到|处理消息\n\n4、完善的消息补偿机制。发送端没收到broker的确认应答，不知道消息是否成功投递成功，这时候就需要做一些补偿处理，比如重新投递。\n\n \n\nrabbitmq的server又叫做broker，接收客户端的连接，实现AMQP实体服务，包含exchange、queue等多种组件。\n\n说白了，broker就是rabbitmq服务器。\n\n \n\n### 实现消息可靠性投递常见的2种方案\n- 消息状态入库，对消息状态进行打标\n- 延时再次投递消息，回调确认\n \n\n#### 消息状态打标\n1、生产者将消息入库、消息状态入库。\n比如用户下单，产生一个Order对象，把这个Order对象数据持久化到数据库中，单独用一张表来存储消息状态：\n用外键关联消息（比如关联订单表的id），\n设置一个status列记录消息投递状态，默认值为0，表示消息未投递到broker；\n设置一个时间列，记录消息投递时间；\n设置一个重试次数列，记录重新投递的次数，默认值为0。\n \n\n2、生产者发送消息到broker\n把Order对象发送到broker，因为消息都要转换为byte[ ]发送，什么类型都可以。\n \n\n3、生产者接收到broker的确认应答，将数据库中该条消息的状态修改为1，表示成功投递\n \n\n4、分布式系统的定时任务\n如果消息投递一段时间后，未收到broker的确认应答，怎么补偿处理？使用定时任务来做：\n\n生产者每隔一段时间，比如5min，启动一条线程来查询数据库中重试次数达到指定值（比如3）、且投递时间已超过指定值（比如5min）的消息，将其状态修改为2，表示重试指定次数后仍未能成功投递；\n\n再查询状态为0、且发送时间已超过指定时间的消息，重新投递，并更新投递时间为当前时间、重试次数+1；\n \n\n第一种方案存在的问题\n生产者执行定时任务也有额外的开销，生产者要进行2方面的数据库IO操作（消息本身+消息状态），IO是很花时间的，在高并发的情况下，数据库性能很容易成为系统性能的瓶颈。\n\n并发量大的情况下，第一种方案严重拉低生产者的性能。\n\n相比之下，第二种方案用得更多，但稍微复杂一点。\n\n \n\n#### 延时再次投递消息\n1、生产者将消息入库，并将消息发送给broker，broker将消息放到对应的queue1中\n \n\n2、消费者监听queue1，处理消息，处理一条消息后产生一条新消息作为确认（绑定queue2），比如以Order的id作为新消息，总之要能唯一标识处理的消息。\n \n\n3、消费者将产生的消息发送给broker，broker将消息放到queue2中（注意不是消费者监听的queue1）\n \n\n4、单独写一个callback service（回调服务），来监听queue2，把queue2中的消息入库，比如放在tb_msg_processed表中，一条记录代表一条已被消费者处理的消息\n \n\n5、生产者发送消息后，延时再次发送这条消息（绑定queue3），比如3min|5min后再次发送这条消息。\n \n\n6、回调服务监听queue3，把queue中消息与数据库中的记录对比，比如把queue3获取到的Order的id取出来，查询tb_msg_processed中有没有这个Order id，有就说明投递成功；没有就说说明未投妥，回调服务rpc通知生产者（传递order id），生产者从数据库查询该条消息的数据（order对象），重新投递（queue1）——重新走一遍流程。\n\n \n\n第一种方案消费者使用数据包来确认应答（ack），第二种由消费者自己产生一条消息来确认应答。\n\n整个流程中，生产者又叫做upstream service（上游服务），消费者又叫做downstream service（下游服务）。\n \n\n\n第二种方案的优缺点\n相较于第一种方案，第二种方案多写一个服务，每对生产者——消费者都使用一个额外的queue来确认，回调服务开发成本高些、略微复杂些；\n\n部署回调服务又要使用、维护额外的机器，成本变高了。\n\n但生产者的数据库IO操作减少了，提升了性能。只要性能上去，稍微增加点成本完全可以接受。\n\n \n\n### 说明\n（1）消息入库完成，然后发送消息（Order对象）到broker，注意顺序\n\n（2）分布式事务对性能的影响很大，并发量中小的可以加事务，如果并发量很大，事务会严重拉低性能，不建议加事务（能不加就不加）\n\n（3）不管是第一种、还是第二种，都很难做到100%的投递成功。优先考虑能够扛得住高并发（性能），在保证性能的前提下尽可能提高消息投递的可靠性\n\n', 32, 'RabbitMQ', 'rabbitmq可靠性投递', 1, 0, 0, 0, '2020-06-27 19:44:20', '2020-06-27 19:44:20');
INSERT INTO `tb_blog` VALUES (19, '设计模式总结', '', 'http://127.0.0.1:9501/admin/dist/img/rand/33.jpg', '\n### 软件设计七大原则\n- 开闭原则：开放扩展、关闭修改。抽象出接口，可实现接口、继承类进行扩展，但尽量不要修改接口。\n- 依赖倒置原则：高层某块不应该依赖低层模块的具体实现，而是依赖低层模块的接口，将耦合度降低到接口层次\n- 单一职责原则：一个类、接口、方法只负责一项功能，降低类的复杂度、变更引起的风险，提高类的可读性，易于维护\n- 接口隔离原则：接口之间相互独立，尽量通过接口来访问\n- 迪米特原则：又叫做最少知道原则，使用其它模块时只关心暴露出来的接口，不关系内部的具体实现\n- 里氏替换原则：父类对象都可以替换为子类对象，即父类适用的地方，子类也应该适用\n- 组合复用原则：尽量用包含来代替继承实现复用，eg. controller要使用某个service，尽量写成成员变量包含进来，而不是继承service\n\n只是参考，根据需求使用\n\n&nbsp;\n\n### 设计模式简介\n标准的设计模式有23种，简单工厂不属于标准设计模式，但用得也多。\n\n设计模式可分为3类\n- 创建型：用于设计对象的创建方式\n- 结构型：用于设计类的结构、类之间的结构\n- 行为型：用于设计类的行为\n\n&nbsp;\n\n### 创建型（1+5种）\n#### 简单工厂（不属于标准的设计模式）\n一个工厂创建多个类的实例\n```java\n//写成实例方法、静态方法均可\npublic class UserFactory{\n    public Student getStudent(){\n        return new Student();\n    }\n\n    public Teacher getTeacher(){\n        return new Teacher();\n    }\n}\n```\n优点：简单；缺点：与多个类耦合在一起，不好扩展\n\n工厂都具有的优点：通过工厂创建对象，无需了解具体创建过程\n\n&nbsp;\n\n#### 工厂方法\n一个工厂只创建一个类的实例，使用各自的工厂创建各自的实例\n\n```java\n//写成接口、抽象类均可，不要也行\npublic interface UserFactory{\n    User getUser();\n}\n```\n\n```java\npublic class StudentFactory implements UserFactory{\n    @Override\n    public User getUser() {\n        return new Student();\n    }\n}\n```\n\n```java\npublic class TeacherFactory implements UserFactory{\n    @Override\n    public User getUser() {\n        return new Teacher();\n    }\n}\n```\n优点：扩展性好；缺点：需要写很多工厂类\n\n&nbsp;\n\n#### 抽象工厂\n顾名思义，对工厂进行抽象，常用于多个对象的组装\n```java\n//对工厂的抽象\npublic interface ComputorFactory{\n	//多个对象\n    Cpu getCpu(String cpu);\n    Memory getMemory(String memory);\n    Disk getDisk(String disk);\n}\n```\n\n```java\npublic class MacComputorFactory implements ComputorFactory{\n\n    @Override\n    public Cpu getCpu() {\n        return new Cpu(\"i5\");\n    }\n\n    @Override\n    public Memory getMemory() {\n        return new Memory(\"ddr3 8g\");\n    }\n\n    @Override\n    public Disk getDisk() {\n        return new Disk(\"ssd 256g\");\n    }\n    \n}\n```\n\n```java\npublic class MacProComputorFactory implements ComputorFactory{\n\n    @Override\n    public Cpu getCpu() {\n        return new Cpu(\"i7\");\n    }\n\n    @Override\n    public Memory getMemory() {\n        return new Memory(\"ddr4 16g\");\n    }\n\n    @Override\n    public Disk getDisk() {\n        return new Disk(\"ssd 500g\");\n    }\n    \n}\n```\n优点：可组装多个不同类型的对象；缺点：在工厂实现中可能有较多的重复代码\n&nbsp;\n\n#### 建造者模式\n通过建造者来建造对象的各部分成员，常用于建造成员变量本身比较复杂的对象\n```java\n@Getter\n@Setter\npublic class Computor {\n    private String cpu;\n    private String memory;\n    private String disk;\n}\n```\n\n```java\n//建造者\n//写成接口、抽象类均可，不要也行\npublic interface ComputerBuilder{\n    void buildCpu(String cpu);\n    void buildMemory(String memory);\n    void buildDisk(String disk);\n    Commputor getComputor();\n}\n```\n\n```java\npublic class ComputerActualBuilder implements ComputerBuilder {\n    private Computer computer = new Computor();  //要建造的对象，空参构造器\n\n    @Override\n    public void buildCpu(String cpu) {\n        computor.setCpu(cpu);  //实际建造时不会这么简单，往往是很复杂的操作\n    }\n\n    @Override\n    public void buildMemory(String memory) {\n        computor.setMemory(memory);\n    }\n\n    @Override\n    public void buildDisk(String disk) {\n        computor.setDisk(disk);\n    }\n    \n    @Override\n    public void getComputor() {\n        return computor;\n    }\n    \n}\n```\n\n```java\n//生产者\n@Setter  //提供setter方法注入建造者\nclass ComputerProducer {\n    private ComputerBuilder computerBuilder;  //建造者\n\n    public Computor buildComputer(String cpu, String memory, String disk){\n        computerBuilder.buildCpu(cpu);  //开始建造\n        computerBuilder.buildMemory(memory);\n        computerBuilder.buildDisk(disk);\n        return computerBuilder.getComputor();  //返回建造好的对象\n    }\n\n}\n```\n\n```java\n//使用\nComputerBuilder computerBuilder = new ComputerActualBuilder();  //建造者\nComputerProducer computerProducer = new ComputerProducer();  //生产者\ncomputerAssembler.setComputerBuilder(computerBuilder);  //注入建造者\nComputer computer = computerProducer.buildComputor(\"i7\", \"ddr4 16g\", \"ssd 1t\");  //生产对象\n```\n优点：可建造成员变量本身比较复杂的对象；缺点：编码量大、偏复杂\n\n&nbsp;\n\n#### 单例模式\n在任何时候获取到的都是同一个实例，单例有2种模式\n- 饿汉式：在类加载时就实例化，本身线程安全\n- 懒汉式：在需要使用实例时才实例化，可能是线程不安全的，需要用一些方式实现线程安全\n\n```java\n//饿汉式\npublic class A {\n    private static A a = new A();  //用静态成员保存实例，调用构造方法创建实例，类加载时就初始化静态成员\n    //.....   //其它成员\n\n    private A(){  //private 隐藏构造器\n\n    }\n\n    public static A getInstance(){  //把获取实例的方法暴露出去。只有1步，原子性，线程安全\n        return a;\n    }\n\n	//....  //其它方法\n\n}\n```\n\n```java\n//懒汉式\nclass A {\n    private static volatile A a=null;  //volatile禁止指令重排序\n    //.....   //其它成员\n\n    private A(){\n\n    }\n\n    public static A getInstance(){  //多步，不具有原子性，可能发生并发问题，需要加锁\n        if (null==a){\n            synchronized (A.class){  //创建实例时锁住整个类，锁的优化写法\n                a = new A();\n            }\n        }\n        return a;\n    }\n\n    //.....   //其它方法\n\n}\n```\n优点：只有1个实例，节约资源；缺点：扩展性差\n\n&nbsp;\n\n#### 原型模式\n创建实例时直接克隆已存在的实例，减少重新创建实例的时间开销\n```java\n//Object有clone()方法，但不能直接使用，需要实现Cloneable，重写里面的clone()方法才能使用\npublic class Student implements Cloneable {\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {  //返回类型是Object\n        return super.clone();  //调用Object的clone()\n    }\n    \n}\n```\n\n```java\nStudent student = new Student();\ntry {\n    Student student1 = (Student) student.clone();  //通过克隆来创建实例\n} catch (CloneNotSupportedException e) {\n    e.printStackTrace();\n}\n```\nclone()直接复制二进制流，不调用构造器创建实例。\n\nclone()是浅拷贝，如果有引用型的成员变量，要额外做一些操作实现深拷贝\n\n```java\npublic class Student implements Cloneable {\n    private Teacher teacher;  //引用型成员变量。注意：Teacher类也要实现Cloneable接口，并重写clone()方法\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        Student student = (Student) super.clone();  //克隆整个对象\n        student.teacher = student.teacher.clone();  //克隆引用型成员，指向新克隆出来的\n        return student;\n    }\n    \n}\n```\n优点：减少了重新创建实例的时间开销；缺点：有引用型成员变量时可能会写成浅拷贝，从而引发一些问题\n\n&nbsp;\n\n### 结构型（7种）\n#### 外观模式（门面模式）\n向外部提供统一的接口来访问，外部不直接访问具体的业务方法\n\neg. controller -> service -> dao，将controller作为接口暴露给外部调用，外部不直接访问处理业务的service、dao\n\n优点：无需了解内部具体实现，方便模块间调用；缺点：修改业务方法时，可能会影响暴露出来的接口，维护难度增加\n\n&nbsp;\n\n#### 装饰者模式\n在保留原有功能的基础上进行扩展\n\n```java\n//原类\n@Getter\npublic class Computor {\n    private String cpu=\"i7\";\n    private String memory=\"8g\";\n    private String disk=\"500g ssd\";\n    private double sum = 6000;  //总价\n}\n```\n\n```java\n//装饰者。可以使用多个装饰者添加不同的功能\npublic class ComputorDecorator {\n    private Computor computor;  //要被装饰的对象，写成成员变量的形式\n    \n    private double memoryPrice = 200; //8g内存单价\n    private double diskPrice = 500;  //1t机械硬盘单价\n    private int memoryCount;  //加装内存条数量\n    private int diskCount;  //加装机械硬盘数量，0表示不加装，1表示加装1个\n    \n    //注入要被装饰的对象\n    public ComputorDecorator(Computor computor){  \n        this.computor = computor;\n    }\n  \n    //加装一条8g内存\n    public void addMemory() {\n        if (this.memoryCount==0)\n            this.memoryCount = 1;\n        else\n            System.out.println(\"只能加装1条\");\n    }\n\n    //加装1t机械硬盘\n    public void addDisk() {\n        if (this.diskCount==0)\n            this.diskCount = 1;\n        else\n            System.out.println(\"只能加装1个机械硬盘\");\n    }\n\n    public double sum() {  //总价\n        return computor.getSum() + memoryPrice * memoryPrice + diskCount * diskPrice;  //在原价的基础上加\n    }\n\n}\n```\n\n```java\n//用装饰者代替原来的对象来使用\nComputor computor = new Computor();\nComputorDecorator computorDecorator = new ComputorDecorator(computor);\n\ncomputorDecorator.addMemory();  //加装一条8g内存\nDouble sum = computorDecorator.sum();\n```\n\n优点：继承可以扩展类，但破坏了原类的封装性，装饰者模式提供了一种新的类扩展方式，不会破坏原类的封装\n\n&nbsp;\n\n#### 适配器模式\n把接口、类变成期待的接口、类\n\n```java\n//我们想要的接口\npublic interface PayService{\n    void pay();\n}\n```\n\n```java\n//对方给的实现\npublic class WXPay{\n    public void wxPay(){  //我们要的是pay()，给的却是wxPay()，对接不上\n\n    }\n}\n```\n\n```java\n//适配器。不用修改我们使用的PayService接口，注入实例时注入PayAdapter即可，用PayService代替原来的实现类WXPay工作\nclass PayAdapter extends WXPay implements PayService{\n\n    @Override\n    public void pay() {  //适配方法\n        super.wxPay();  //调用WXPay中对应的方法\n    }\n\n}\n```\n适配器一般是在对接、维护阶段使用的，提供的类、接口与期待不符，用来亡羊补牢，修正\n\n&nbsp;\n\n#### 享元模式\n对于频繁使用的实例，每次都重新创建会很消耗资源、花费时间，可以先创建好一些实例放到集合中，使用时直接从集合中取，用完重置为初始值放到集合中。\n\n享元模式的常见应用比如线程池、连接池\n\n&nbsp;\n\n#### 组合模式\n组合模式用于将多个对象（节点）组合成树形结构，常用于菜单、文件系统、家谱等\n\n```java\n//成员\npublic class Member{\n    private String name;  //姓名\n    private String gender;  //性别\n\n    public Member(String name, String gender) {\n        this.name = name;\n        this.gender = gender;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getGender() {\n        return gender;\n    }\n\n    //可能要改名\n    public void setName(String name) {\n        this.name = name;\n    }\n\n}\n```\n\n```java\n//男性成员，记录老婆、孩子\npublic class MaleMember extends Member{\n    private String wife;  //老婆\n    private ArrayList<Member> children = new ArrayList<>();  //孩子\n\n    public MaleMember(String name, String gender) {\n        super(name, gender);\n    }\n\n    public String getWife() {\n        return wife;\n    }\n\n    public void setWife(String wife) {\n        this.wife = wife;\n    }\n\n    //添加一个孩子\n    public void addChild(Member member){\n        children.add(member);\n    }\n\n    //获取所有孩子\n    public ArrayList<Member> getChildren() {\n        return children;\n    }\n}\n```\n\n```java\n//女性成员，要出嫁，只记录丈夫，不记录其子女\npublic class FemaleMember extends Member{\n    private String husband;  //丈夫\n\n    public FemaleMember(String name, String gender) {\n        super(name, gender);\n    }\n\n    public String getHusband() {\n        return husband;\n    }\n\n    public void setHusband(String husband) {\n        this.husband = husband;\n    }\n\n}\n```\n\n```java\n//使用\nMaleMember ly = new MaleMember(\"李渊\",\"男\");\nly.setWife(\"窦皇后\");  //李渊娶老婆\n\nMaleMember lsm = new MaleMember(\"李世民\",\"男\");  //李世民出生\nly.addChild(lsm); \n\nlsm.setWife(\"长孙皇后\");  //李世民娶老婆\n```\n\n&nbsp;\n\n#### 桥接模式\n①抽象与具体实现分离，②使用组合代替继承建立类之间的联系\n```java\ninterface UserDao{\n    void addUser(User user);\n    void deleteUser(int id);\n    User findUserById(int id);\n    void updateUser(User user);\n}\n\n//抽象（接口、抽象类）与具体实现分离\n\n@Repository\nclass UserDaoImpl implements UserDao{\n\n    @Override\n    public void addUser(User user) {\n\n    }\n\n    @Override\n    public void deleteUser(int id) {\n\n    }\n\n    @Override\n    public User findUserById(int id) {\n        return null;\n    }\n\n    @Override\n    public void updateUser(User user) {\n\n    }\n}\n```\n\n```java\ninterface UserService {\n    void addUser(User user);\n    void deleteUser(int id);\n    User findUserById(int id);\n    void updateUser(User user);\n}\n\n//抽象（接口、抽象类）与具体实现分离\n\n@Service\nclass UserServiceImpl implements UserService{\n    @Autowired\n    private UserDao userDao;  //使用组合代替继承建立类之间的联系\n\n    @Override\n    public void addUser(User user) {\n        userDao.addUser(user);\n    }\n\n    @Override\n    public void deleteUser(int id) {\n        userDao.deleteUser(id);\n    }\n\n    @Override\n    public User findUserById(int id) {\n        return userDao.findUserById(id);\n    }\n\n    @Override\n    public void updateUser(User user) {\n        userDao.updateUser(user);\n    }\n}\n```\n抽象（接口、抽象类）、实现分离，组合时使用抽象，将耦合降低到抽象层次\n\n&nbsp;\n\n#### 代理模式\n对原类进行增强，用代理代替原类进行工作，常用于aop\n\n参考：[https://blog.csdn.net/chy_18883701161/article/details/106509363](https://blog.csdn.net/chy_18883701161/article/details/106509363)\n\n&nbsp;\n\n### 行为型（11种）\n#### 模板方法\n将业务划分为多个步骤（方法），在模板方法中调用这些方法，组成完整的业务处理流程。\n\n常用于流程相同、相似的业务处理，可重写模板方法提供不同的处理方式\n\n```java\n//招聘\npublic abstract class Recruit{\n\n    //笔试\n    public boolean writtenTest(){\n\n    }\n\n    //面试\n    public boolean interview(){\n\n    }\n\n    //发放offer\n    public void issueOffer(){\n\n    }\n\n    //模板方法，招聘，在模板方法中调用其它方法，组成完整的业务流程\n    public abstract void recruit();\n\n}\n```\n\n```java\n//通用招聘，笔试->面试->发放offer\npublic class CommonRecruit extends Recruit{\n\n    //模板方法\n    @Override\n    public void recruit(){\n        //笔试\n        if (this.writtenTest() == true) {  \n            //通过则进行面试\n            if (this.interview()==true){  \n            	//通过则发放offer\n                issueOffer();  \n            }\n        }\n    }\n\n}\n```\n\n```java\n//内推免笔试，面试->发放offer\nclass RecommendRecruit extends Recruit{\n\n    //模板方法\n    @Override\n    public void recruit(){\n        //面试\n        if (this.interview()==true){  \n        	//通过则发放offer\n            issueOffer();  \n        }\n    }\n\n}\n```\n\n&nbsp;\n\n#### 迭代器模式\n用单独的类作为迭代器Iterator来遍历集合，将数据存储、遍历分离，常见的比如jdk自带的集合的迭代器\n&nbsp;\n\n迭代器一般要有2个方法\n- hasNext()  &emsp;判断是否是最后一个元素（是否还有下一个元素）\n- next()   &emsp;获取下一个元素\n\n&nbsp;\n\n#### 策略模式\n封装处理同一业务的多种策略，根据需求切换不同的策略即可，不需要了解策略的具体实现\n\n常见的比如spring的7种事务传播策略、数据库的4种隔离级别、线程池的4种拒绝策略、促销方案、出行线路选择（最短时间、最低花费、最少换乘）等\n\n```java\n//促销策略接口\npublic interface SalePromotionStrategy {\n\n    //传入总金额，返回折算后总金额\n    double doPromotion(double sum);\n\n}\n```\n\n```java\n//策略一：满100减20\nclass Strategy1 implements SalePromotionStrategy{\n\n    @Override\n    public double doPromotion(double sum) {\n        if (sum >= 100){\n            sum -= 20;\n        }else{\n            System.out.println(\"亲，尚不满足满减条件\");\n        }\n        return sum;\n    }\n\n}\n\n\n//策略二：满300减100\nclass Strategy2 implements SalePromotionStrategy {\n\n    @Override\n    public double doPromotion(double sum) {\n        if (sum >= 300){\n            sum -= 100;\n        }else{\n            System.out.println(\"亲，您的购买金额尚未达到300元呢\");\n        }\n        return sum;\n    }\n\n}\n\n\n//策略三：满1000减500\nclass Strategy3 implements SalePromotionStrategy {\n\n    @Override\n    public double doPromotion(double sum) {\n        if (sum >= 1000){\n            sum -= 500;\n        }else{\n            System.out.println(\"亲，您的购物金额尚未达到1000元呢\");\n        }\n        return sum;\n    }\n\n}\n```\n\n```java\n//使用时，把策略接口写成成员变量，提供setter方法用于注入、修改策略\n//直接使用策略即可。无需关心策略的具体实现，修改策略时无需修改其它部分\nprivate SalePromotionStrategy strategy;\n\npublic void setSalePromotionStrategy(SalePromotionStrategy strategy) {\n    this.strategy = strategy;\n}\n\n\n//结算时使用指定策略计算出优惠后的应付金额\ndouble paySum = this.strategy.doPromotion(sum);\n```\n\n&nbsp;\n\n#### 解释器模式\n将语句按照自定义的方式解释执行\n\neg. 可以自定义字符串、数字之间的\\*解释执行规则是：拼接n个相同的字符串， \"hello\"\\*2  => \"hellohello\"\n\n解释器模式基本不用，此处不详细说明\n\n&nbsp;\n\n#### 观察者模式\n对象可以被其它对象观察，对象状态改变时，自动通知观察者，常用于博客文章的相关通知、朋友圈的评论回复、系统消息通知等\n\n```java\n//博文，做为被观察的对象\n//被观察的对象需要继承Observable，使用Observable提供的方法来通知观察者。Observable提供了很多线程安全的方法\npublic class Article extends Observable {\n    private String title;\n    //....\n\n    public Article(String title) {\n        this.title = title;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    //点赞。传入点赞者\n    public void dz(String username){\n        setChanged();  //标识状态改变\n        HashMap<String, String> map = new HashMap<>(2);  //最多只能携带一个参数，有多个参数时可以放在map中传过去\n        map.put(\"type\", \"dz\");\n        map.put(\"username\", username);\n        notifyObservers(map);  //通知所有观察者，可以传一个Object参数，也可以不传\n    }\n\n    //收藏\n    public void sc(String username){\n        setChanged();\n        HashMap<String, String> map = new HashMap<>(2);\n        map.put(\"type\", \"sc\");\n        map.put(\"username\", username);\n        notifyObservers(username);\n    }\n\n    //评论。传入评论者、评论内容\n    public void comment(String username,String comment){\n        setChanged();\n        HashMap<String, String> map = new HashMap<>(3);\n        map.put(\"type\", \"comment\");\n        map.put(\"username\", username);\n        map.put(\"comment\", comment);\n        notifyObservers(map);\n    }\n\n}\n```\n\n```java\n//用户，作为观察者，观察者需要实现Observer接口\npublic class User implements Observer {\n    private String username;\n    //.....\n\n    public User(String username) {\n        this.username = username;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    //处理所有来自被观察者的通知\n    @Override\n    public void update(Observable o, Object arg) {  //被观察的对象、传过来的参数\n        Article article = (Article) o;  //被观察的对象。如果同时观察多个对象，往往要先判断对象类型，根据对象类型作出相应的处理\n        Map<String,String> map = (Map<String, String>) arg;\n        String type = map.get(\"type\");\n        String username = map.get(\"username\");\n        switch (type){\n            case \"dz\":\n                System.out.println(username + \"点赞了你的博文\" + article.getTitle());\n                break;\n            case \"sc\":\n                System.out.println(username + \"收藏了你的博文\" + article.getTitle());\n\n                break;\n            case \"comment\":\n                String comment = map.get(\"comment\");\n                System.out.println(username + \"评论了你的博文\" + article.getTitle() + \"：\" + comment);\n        }\n    }\n\n}\n```\n\n```java\n//使用\nUser chy = new User(\"chy\");  //我\nUser zs = new User(\"zhangsan\");  //张三\nUser ls = new User(\"lisi\");  //李四\n\nArticle article = new Article(\"《设计模式总结》\");  //我的一篇博客\narticle.addObserver(chy);  //设置观察者，对象发生改变时会通知观察者。可用多个addObserver()设置多个观察者\n\narticle.dz(zs.getUsername());  //张三点赞我的博文\narticle.comment(ls.getUsername(),\"总结得不错\");  //李四评论我的博文\n```\n\n&nbsp;\n\n#### 备忘录模式\n保存对象状态，后续可恢复对象至某个状态\n&nbsp;\n\n备忘录用得不多，一般只用于特定的开发场景，比如\n- 开发文本编辑器：Ctrl+Z撤销操作、恢复到上一步\n- 开发游戏：进度存档\n\n&nbsp;\n简单说一下\n```java\nclass Article{\n    private String title;\n    private String content;\n    //.....\n}\n```\n\n```java\nclass ArticleStack{\n    private Stack<Article> stack = new Stack<>();  \n    //.....\n}\n```\npush对象到栈中，存储对象不同时期的状态，栈是后进先出的，还原时pop()获取上一次的状态进行还原\n\n&nbsp;\n\n#### 命令模式\n将操作封装为命令对象，通过命令对象来执行操作\n\n```java\n//命令接口\npublic interface Command{\n    void execute();  //执行命令\n}\n```\n\n```java\n//命令\n//开放CET4、6的报名通道\npublic class CETApplyOpen implements Command{\n\n    @Override\n    public void execute() {\n        //....  //开放cet4、6的报名通道\n    }\n\n}\n\n//关闭CET4、6的报名通道\npublic class CETApplyClose implements Command{\n\n    @Override\n    public void execute() {\n        //....  //关闭cet4、6的报名通道\n    }\n\n}\n\n\n//开放CET4、6的查分通道\npublic class CETQueryOpen implements Command{\n\n    @Override\n    public void execute() {\n        //....  //开放cet4、6的查分通道\n    }\n\n}\n\n//关闭CET4、6的查分通道\npublic class CETQueryClose implements Command{\n\n    @Override\n    public void execute() {\n        //....  //关闭cet4、6的查分通道\n    }\n\n}\n```\n\n```java\n//执行命令\n\n//把Command作为成员变量，注入要执行的Command对象\nprivate Command command;\n\n//调用execute()执行命令即可\ncommand.execute();\n```\n\n&nbsp;\n\n#### 中介者模式\n对象之间不直接交互，通过中介者来进行交互\n\neg. 群聊、聊天室，把群聊、聊天室作为中介者，用户之间通过聊天室进行交流\n\n&nbsp;\n\n#### 责任链模式（职责链模式）\n一个请求需要多个操作或对象依次处理，形成一条处理链路，常见的比如拦截器栈\n\n\n```java\n//Handler抽象类\npublic abstract class Handler{\n    protected Handler handler;  //下一个handler。类似链表\n\n    public void setHandler(Handler handler) {  //设置下一个handler\n        this.handler = handler;\n    }\n\n    public abstract void handler();  //当前handler的处理\n\n}\n```\n\n```java\n//Handler的实现类\n\nclass Handler1 extends Handler{\n\n    @Override\n    public void handler() {\n        //....   //当前handler的处理\n        if ( this.handler != null){\n            this.handler.handler();  //调用下一个handler进行处理\n        }\n    }\n\n}\n\n\nclass Handler2 extends Handler{\n\n    @Override\n    public void handler() {\n        //....   //当前handler的处理\n        if ( this.handler != null){\n            this.handler.handler();  //调用下一个handler进行处理\n        }\n    }\n\n}\n```\n\n```java\n//使用多个handler依次处理请求\nHandler1 handler1 = new Handler1();\nHandler2 handler2 = new Handler2();\nhandler1.setHandler(handler2);  //设置下一个handler\n\n//使用handler1接收请求即可\n```\n\n&nbsp;\n\n#### 访问者模式\n根据访问者类型，展示相应的内容，通常要校验用户权限\n\neg. 有些信息只给vip看，有些信息只给管理员看\n\n&nbsp;\n\n#### 状态模式\n对象存在多种状态，处于不同状态时支持的行为不同。\n\neg. 订单处于已创建状态时可以付款，处于已付款状态时可以发货，处于已发货状态时可以签收，处于已签收状态时可以进行售后\n\n```java\n//订单状态，抽象类\npublic abstract class OrderStatus{\n    private String status;\n\n    public String getStatus() {\n        return status;\n    }\n\n    public void setStatus(String status) {\n        this.status = status;\n    }\n}\n```\n\n```java\n//已创建状态\nclass CreatedOrderStatus extends OrderStatus{\n\n    {\n        super.setStatus(\"created\");\n    }\n\n    //付款操作\n    public void pay(){\n\n    }\n}\n\n\n//已付款状态\nclass PaidOrderStatus extends OrderStatus{\n\n    {\n        super.setStatus(\"paid\");\n    }\n\n    //发货操作\n    public void send(){\n\n    }\n}\n\n\n//已发货状态\nclass SentOrderStatus extends OrderStatus{\n\n    {\n        super.setStatus(\"sent\");\n    }\n\n    //签收操作\n    public void receive(){\n\n    }\n}\n\n\n//已签收状态\nclass ReceivedOrderStatus extends OrderStatus{\n\n    {\n        super.setStatus(\"received\");\n    }\n\n    //售后操作\n    public void afterSale(){\n\n    }\n}\n```\n\n```java\nclass Order{\n    private OrderStatus orderStatus = new CreatedOrderStatus();  //使用一个成员来保存状态，状态变化时需要更新此成员\n    //.....\n\n}\n```\n', 33, '设计模式', '设计模式', 1, 0, 0, 0, '2020-06-27 19:46:00', '2020-06-27 19:46:00');

-- ----------------------------
-- Table structure for tb_blog_category
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog_category`;
CREATE TABLE `tb_blog_category`  (
  `category_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '分类表主键',
  `category_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '分类的名称',
  `category_icon` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '分类的图标',
  `category_rank` int(0) NOT NULL DEFAULT 1 COMMENT '分类的排序值 被使用的越多数值越大',
  `is_deleted` tinyint(0) NOT NULL DEFAULT 0 COMMENT '是否删除 0=否 1=是',
  `create_time` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  PRIMARY KEY (`category_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 25 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_blog_category
-- ----------------------------
INSERT INTO `tb_blog_category` VALUES (25, 'Git', '/admin/dist/img/category/03.png', 2, 1, '2020-06-27 19:05:17');
INSERT INTO `tb_blog_category` VALUES (26, '多线程', '/admin/dist/img/category/00.png', 3, 0, '2020-06-27 19:20:23');
INSERT INTO `tb_blog_category` VALUES (27, '分布式', '/admin/dist/img/category/00.png', 3, 0, '2020-06-27 19:26:17');
INSERT INTO `tb_blog_category` VALUES (28, 'JVM', '/admin/dist/img/category/00.png', 5, 0, '2020-06-27 19:29:07');
INSERT INTO `tb_blog_category` VALUES (29, 'ZK', '/admin/dist/img/category/00.png', 2, 0, '2020-06-27 19:32:59');
INSERT INTO `tb_blog_category` VALUES (30, 'Redis', '/admin/dist/img/category/00.png', 3, 0, '2020-06-27 19:34:18');
INSERT INTO `tb_blog_category` VALUES (31, 'MyBatis', '/admin/dist/img/category/00.png', 2, 0, '2020-06-27 19:36:34');
INSERT INTO `tb_blog_category` VALUES (32, 'RabbitMQ', '/admin/dist/img/category/00.png', 2, 0, '2020-06-27 19:44:32');
INSERT INTO `tb_blog_category` VALUES (33, '设计模式', '/admin/dist/img/category/00.png', 2, 0, '2020-06-27 19:45:34');

-- ----------------------------
-- Table structure for tb_blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog_comment`;
CREATE TABLE `tb_blog_comment`  (
  `comment_id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `blog_id` bigint(0) NOT NULL DEFAULT 0 COMMENT '关联的blog主键',
  `commentator` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '评论者名称',
  `email` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '评论人的邮箱',
  `website_url` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '网址',
  `comment_body` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '评论内容',
  `comment_create_time` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '评论提交时间',
  `commentator_ip` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '评论时的ip地址',
  `reply_body` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '回复内容',
  `reply_create_time` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '回复时间',
  `comment_status` tinyint(0) NOT NULL DEFAULT 0 COMMENT '是否审核通过 0-未审核 1-审核通过',
  `is_deleted` tinyint(0) NULL DEFAULT 0 COMMENT '是否删除 0-未删除 1-已删除',
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 27 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_blog_comment
-- ----------------------------

-- ----------------------------
-- Table structure for tb_blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog_tag`;
CREATE TABLE `tb_blog_tag`  (
  `tag_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '标签表主键id',
  `tag_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '标签名称',
  `is_deleted` tinyint(0) NOT NULL DEFAULT 0 COMMENT '是否删除 0=否 1=是',
  `create_time` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  PRIMARY KEY (`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 135 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_blog_tag
-- ----------------------------
INSERT INTO `tb_blog_tag` VALUES (136, '多线程', 0, '2020-06-27 19:21:48');
INSERT INTO `tb_blog_tag` VALUES (137, '线程安全', 0, '2020-06-27 19:23:01');
INSERT INTO `tb_blog_tag` VALUES (138, 'CAP理论', 0, '2020-06-27 19:27:00');
INSERT INTO `tb_blog_tag` VALUES (139, '幂等性', 0, '2020-06-27 19:28:07');
INSERT INTO `tb_blog_tag` VALUES (140, 'jvm架构', 0, '2020-06-27 19:30:27');
INSERT INTO `tb_blog_tag` VALUES (141, 'jvm类加载机制', 0, '2020-06-27 19:31:17');
INSERT INTO `tb_blog_tag` VALUES (142, 'JVM垃圾回收机制', 0, '2020-06-27 19:31:55');
INSERT INTO `tb_blog_tag` VALUES (143, 'zk', 0, '2020-06-27 19:33:28');
INSERT INTO `tb_blog_tag` VALUES (144, 'redis持久化', 0, '2020-06-27 19:34:53');
INSERT INTO `tb_blog_tag` VALUES (145, 'redis集群', 0, '2020-06-27 19:35:40');
INSERT INTO `tb_blog_tag` VALUES (146, 'mybatis', 0, '2020-06-27 19:37:13');
INSERT INTO `tb_blog_tag` VALUES (147, 'rabbitmq可靠性投递', 0, '2020-06-27 19:44:20');
INSERT INTO `tb_blog_tag` VALUES (148, '设计模式', 0, '2020-06-27 19:46:00');

-- ----------------------------
-- Table structure for tb_blog_tag_relation
-- ----------------------------
DROP TABLE IF EXISTS `tb_blog_tag_relation`;
CREATE TABLE `tb_blog_tag_relation`  (
  `relation_id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '关系表id',
  `blog_id` bigint(0) NOT NULL COMMENT '博客id',
  `tag_id` int(0) NOT NULL COMMENT '标签id',
  `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '添加时间',
  PRIMARY KEY (`relation_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 280 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_blog_tag_relation
-- ----------------------------
INSERT INTO `tb_blog_tag_relation` VALUES (280, 6, 135, '2020-06-27 19:05:58');
INSERT INTO `tb_blog_tag_relation` VALUES (281, 7, 136, '2020-06-27 19:21:48');
INSERT INTO `tb_blog_tag_relation` VALUES (282, 8, 137, '2020-06-27 19:23:01');
INSERT INTO `tb_blog_tag_relation` VALUES (283, 9, 138, '2020-06-27 19:27:00');
INSERT INTO `tb_blog_tag_relation` VALUES (284, 10, 139, '2020-06-27 19:28:07');
INSERT INTO `tb_blog_tag_relation` VALUES (285, 11, 140, '2020-06-27 19:30:27');
INSERT INTO `tb_blog_tag_relation` VALUES (286, 12, 141, '2020-06-27 19:31:17');
INSERT INTO `tb_blog_tag_relation` VALUES (287, 13, 142, '2020-06-27 19:31:55');
INSERT INTO `tb_blog_tag_relation` VALUES (288, 14, 143, '2020-06-27 19:33:28');
INSERT INTO `tb_blog_tag_relation` VALUES (289, 15, 144, '2020-06-27 19:34:53');
INSERT INTO `tb_blog_tag_relation` VALUES (290, 16, 145, '2020-06-27 19:35:40');
INSERT INTO `tb_blog_tag_relation` VALUES (291, 17, 146, '2020-06-27 19:37:13');
INSERT INTO `tb_blog_tag_relation` VALUES (293, 18, 147, '2020-06-27 19:44:46');
INSERT INTO `tb_blog_tag_relation` VALUES (294, 19, 148, '2020-06-27 19:46:00');

-- ----------------------------
-- Table structure for tb_config
-- ----------------------------
DROP TABLE IF EXISTS `tb_config`;
CREATE TABLE `tb_config`  (
  `config_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '配置项的名称',
  `config_value` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '配置项的值',
  `create_time` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `update_time` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '修改时间',
  PRIMARY KEY (`config_name`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_config
-- ----------------------------
INSERT INTO `tb_config` VALUES ('footerAbout', 'blog. have fun', '2018-11-11 20:33:23', '2020-06-27 10:36:22');
INSERT INTO `tb_config` VALUES ('footerCopyRight', '2019 chy_18883701161', '2018-11-11 20:33:31', '2020-06-27 10:36:22');
INSERT INTO `tb_config` VALUES ('footerICP', '川ICP备xxxxxx号-x', '2018-11-11 20:33:27', '2020-06-27 10:36:22');
INSERT INTO `tb_config` VALUES ('footerPoweredBy', 'https://github.com/chy18883701161', '2018-11-11 20:33:36', '2020-06-27 10:36:22');
INSERT INTO `tb_config` VALUES ('footerPoweredByURL', 'https://github.com/chy18883701161', '2018-11-11 20:33:39', '2020-06-27 10:36:22');
INSERT INTO `tb_config` VALUES ('websiteDescription', 'blog是SpringBoot2+Thymeleaf+Mybatis+MySQL建造的个人博客网站', '2018-11-11 20:33:04', '2020-06-27 10:41:09');
INSERT INTO `tb_config` VALUES ('websiteIcon', '/admin/dist/img/favicon.png', '2018-11-11 20:33:11', '2020-06-27 10:41:09');
INSERT INTO `tb_config` VALUES ('websiteLogo', '/admin/dist/img/logo2.png', '2018-11-11 20:33:08', '2020-06-27 10:41:09');
INSERT INTO `tb_config` VALUES ('websiteName', 'blog', '2018-11-11 20:33:01', '2020-06-27 10:41:09');
INSERT INTO `tb_config` VALUES ('yourAvatar', '/admin/dist/img/chy.png', '2018-11-11 20:33:14', '2020-06-27 10:34:41');
INSERT INTO `tb_config` VALUES ('yourEmail', '3213973159@qq.com', '2018-11-11 20:33:17', '2020-06-27 10:34:41');
INSERT INTO `tb_config` VALUES ('yourName', 'chy_18883701161', '2018-11-11 20:33:20', '2020-06-27 10:34:41');

-- ----------------------------
-- Table structure for tb_link
-- ----------------------------
DROP TABLE IF EXISTS `tb_link`;
CREATE TABLE `tb_link`  (
  `link_id` int(0) NOT NULL AUTO_INCREMENT COMMENT '友链表主键id',
  `link_type` tinyint(0) NOT NULL DEFAULT 0 COMMENT '友链类别 0-友链 1-推荐 2-个人网站',
  `link_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '网站名称',
  `link_url` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '网站链接',
  `link_description` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '网站描述',
  `link_rank` int(0) NOT NULL DEFAULT 0 COMMENT '用于列表排序',
  `is_deleted` tinyint(0) NOT NULL DEFAULT 0 COMMENT '是否删除 0-未删除 1-已删除',
  `create_time` datetime(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '添加时间',
  PRIMARY KEY (`link_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_link
-- ----------------------------

SET FOREIGN_KEY_CHECKS = 1;
